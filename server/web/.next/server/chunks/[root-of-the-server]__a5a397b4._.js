module.exports=[60526,(t,e,i)=>{e.exports=t.x("node:os",()=>require("node:os"))},50227,(t,e,i)=>{e.exports=t.x("node:path",()=>require("node:path"))},27699,(t,e,i)=>{e.exports=t.x("events",()=>require("events"))},41300,(t,e,i)=>{let r=t=>"object"==typeof t&&null!==t,s=t=>r(t)&&"[object Date]"===Object.prototype.toString.call(t);e.exports.uniq=(t,e)=>e?[...new Map(t.map(t=>[e(t),t])).values()]:[...new Set(t)],e.exports.isDate=s,e.exports.isRegExp=t=>r(t)&&"[object RegExp]"===Object.prototype.toString.call(t),e.exports.pick=(t,e)=>e.reduce((e,i)=>(t&&Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]),e),{}),e.exports.filterIndexNames=t=>([e,i])=>!!("string"==typeof i||"number"==typeof i||"boolean"==typeof i||s(i)||null===i)&&t.includes(e)},39637,(t,e,i)=>{let{uniq:r,isDate:s,isRegExp:n}=t.r(41300),a=(t,e)=>{if("number"==typeof t&&(t=t.toString()),"$"===t[0]&&("$$date"!==t||"number"!=typeof e)&&("$$deleted"!==t||!0!==e)&&"$$indexCreated"!==t&&"$$indexRemoved"!==t)throw Error("Field names cannot begin with the $ character");if(-1!==t.indexOf("."))throw Error("Field names cannot contain a .")},o=t=>{if(Array.isArray(t)&&t.forEach(t=>{o(t)}),"object"==typeof t&&null!==t)for(let e in t)Object.prototype.hasOwnProperty.call(t,e)&&(a(e,t[e]),o(t[e]))};function h(t,e){if("boolean"==typeof t||"number"==typeof t||"string"==typeof t||null===t||s(t))return t;if(Array.isArray(t))return t.map(t=>h(t,e));if("object"==typeof t){let i={};for(let r in t)Object.prototype.hasOwnProperty.call(t,r)&&(!e||"$"!==r[0]&&-1===r.indexOf("."))&&(i[r]=h(t[r],e));return i}}let l=t=>"boolean"==typeof t||"number"==typeof t||"string"==typeof t||null===t||s(t)||Array.isArray(t),c=(t,e)=>t<e?-1:+(t>e),d=(t,e)=>{let i=Math.min(t.length,e.length);for(let r=0;r<i;r+=1){let i=u(t[r],e[r]);if(0!==i)return i}return c(t.length,e.length)},u=(t,e,i)=>{let r=i||c;if(void 0===t)return void 0===e?0:-1;if(void 0===e)return 1;if(null===t)return null===e?0:-1;if(null===e)return 1;if("number"==typeof t)return"number"==typeof e?c(t,e):-1;if("number"==typeof e)return"number"==typeof t?c(t,e):1;if("string"==typeof t)return"string"==typeof e?r(t,e):-1;if("string"==typeof e)return"string"==typeof t?r(t,e):1;if("boolean"==typeof t)return"boolean"==typeof e?c(t,e):-1;if("boolean"==typeof e)return"boolean"==typeof t?c(t,e):1;if(s(t))return s(e)?c(t.getTime(),e.getTime()):-1;if(s(e))return s(t)?c(t.getTime(),e.getTime()):1;if(Array.isArray(t))return Array.isArray(e)?d(t,e):-1;if(Array.isArray(e))return Array.isArray(t)?d(t,e):1;let n=Object.keys(t).sort(),a=Object.keys(e).sort();for(let i=0;i<Math.min(n.length,a.length);i+=1){let r=u(t[n[i]],e[a[i]]);if(0!==r)return r}return c(n.length,a.length)},p=(t,e=!1)=>{let i=(r,s,n)=>{let a="string"==typeof s?s.split("."):s;if(1===a.length)t(r,s,n);else{if(void 0===r[a[0]]){if(e)return;r[a[0]]={}}i(r[a[0]],a.slice(1),n)}};return i},y=(t,e,i)=>{if(Object.prototype.hasOwnProperty.call(t,e)||(t[e]=[]),!Array.isArray(t[e]))throw Error("Can't $addToSet an element on non-array values");if(null!==i&&"object"==typeof i&&i.$each){if(Object.keys(i).length>1)throw Error("Can't use another field in conjunction with $each");if(!Array.isArray(i.$each))throw Error("$each requires an array value");i.$each.forEach(i=>{y(t,e,i)})}else{let r=!0;t[e].forEach(t=>{0===u(t,i)&&(r=!1)}),r&&t[e].push(i)}},f={$set:p((t,e,i)=>{t[e]=i}),$unset:p((t,e,i)=>{delete t[e]},!0),$min:p((t,e,i)=>{void 0===t[e]?t[e]=i:i<t[e]&&(t[e]=i)}),$max:p((t,e,i)=>{void 0===t[e]?t[e]=i:i>t[e]&&(t[e]=i)}),$inc:p((t,e,i)=>{if("number"!=typeof i)throw Error(`${i} must be a number`);if("number"!=typeof t[e])if(Object.prototype.hasOwnProperty.call(t,e))throw Error("Don't use the $inc modifier on non-number fields");else t[e]=i;else t[e]+=i}),$pull:p((t,e,i)=>{if(!Array.isArray(t[e]))throw Error("Can't $pull an element from non-array values");let r=t[e];for(let t=r.length-1;t>=0;t-=1)P(r[t],i)&&r.splice(t,1)}),$pop:p((t,e,i)=>{if(!Array.isArray(t[e]))throw Error("Can't $pop an element from non-array values");if("number"!=typeof i)throw Error(`${i} isn't an integer, can't use it with $pop`);0!==i&&(i>0?t[e]=t[e].slice(0,t[e].length-1):t[e]=t[e].slice(1))}),$addToSet:p(y),$push:p((t,e,i)=>{if(Object.prototype.hasOwnProperty.call(t,e)||(t[e]=[]),!Array.isArray(t[e]))throw Error("Can't $push an element on non-array values");if(null!==i&&"object"==typeof i&&i.$slice&&void 0===i.$each&&(i.$each=[]),null!==i&&"object"==typeof i&&i.$each){if(Object.keys(i).length>=3||2===Object.keys(i).length&&void 0===i.$slice)throw Error("Can only use $slice in cunjunction with $each when $push to array");if(!Array.isArray(i.$each))throw Error("$each requires an array value");if(i.$each.forEach(i=>{t[e].push(i)}),void 0===i.$slice||"number"!=typeof i.$slice)return;if(0===i.$slice)t[e]=[];else{let r,s,n=t[e].length;i.$slice<0?(r=Math.max(0,n+i.$slice),s=n):i.$slice>0&&(r=0,s=Math.min(n,i.$slice)),t[e]=t[e].slice(r,s)}}else t[e].push(i)})},g=(t,e)=>{let i="string"==typeof e?e.split("."):e;if(t){if(0===i.length)return t;if(1===i.length)return t[i[0]];if(!Array.isArray(t[i[0]]))return g(t[i[0]],i.slice(1));{let e=parseInt(i[1],10);return"number"!=typeof e||isNaN(e)?t[i[0]].map(t=>g(t,i.slice(1))):g(t[i[0]][e],i.slice(2))}}},m=(t,e)=>{let i,r;if(null===t||"string"==typeof t||"boolean"==typeof t||"number"==typeof t||null===e||"string"==typeof e||"boolean"==typeof e||"number"==typeof e)return t===e;if(s(t)||s(e))return s(t)&&s(e)&&t.getTime()===e.getTime();if(!(Array.isArray(t)&&Array.isArray(e))&&(Array.isArray(t)||Array.isArray(e))||void 0===t||void 0===e)return!1;try{i=Object.keys(t),r=Object.keys(e)}catch(t){return!1}if(i.length!==r.length)return!1;for(let s of i)if(-1===r.indexOf(s)||!m(t[s],e[s]))return!1;return!0},b=(t,e)=>("string"==typeof t||"number"==typeof t||!!s(t)||"string"==typeof e||"number"==typeof e||!!s(e))&&typeof t==typeof e&&!0,w={$lt:(t,e)=>b(t,e)&&t<e,$lte:(t,e)=>b(t,e)&&t<=e,$gt:(t,e)=>b(t,e)&&t>e,$gte:(t,e)=>b(t,e)&&t>=e,$ne:(t,e)=>void 0===t||!m(t,e),$in:(t,e)=>{if(!Array.isArray(e))throw Error("$in operator called with a non-array");for(let i of e)if(m(t,i))return!0;return!1},$nin:(t,e)=>{if(!Array.isArray(e))throw Error("$nin operator called with a non-array");return!w.$in(t,e)},$regex:(t,e)=>{if(!n(e))throw Error("$regex operator called with non regular expression");return"string"==typeof t&&e.test(t)},$exists:(t,e)=>(e=!!e||""===e,void 0===t)?!e:e,$size:(t,e)=>{if(!Array.isArray(t))return!1;if(e%1!=0)throw Error("$size operator called without an integer");return t.length===e},$elemMatch:(t,e)=>!!Array.isArray(t)&&t.some(t=>P(t,e))},A={$size:!0,$elemMatch:!0},v={$or:(t,e)=>{if(!Array.isArray(e))throw Error("$or operator used without an array");for(let i=0;i<e.length;i+=1)if(P(t,e[i]))return!0;return!1},$and:(t,e)=>{if(!Array.isArray(e))throw Error("$and operator used without an array");for(let i=0;i<e.length;i+=1)if(!P(t,e[i]))return!1;return!0},$not:(t,e)=>!P(t,e),$where:(t,e)=>{if("function"!=typeof e)throw Error("$where operator used without a function");let i=e.call(t);if("boolean"!=typeof i)throw Error("$where function must return boolean");return i}},P=(t,e)=>{if(l(t)||l(e))return k({needAKey:t},"needAKey",e);for(let i in e)if(Object.prototype.hasOwnProperty.call(e,i)){let r=e[i];if("$"===i[0]){if(!v[i])throw Error(`Unknown logical operator ${i}`);if(!v[i](t,r))return!1}else if(!k(t,i,r))return!1}return!0};function k(t,e,i,r){let s=g(t,e);if(Array.isArray(s)&&!r){if(Array.isArray(i))return k(t,e,i,!0);if(null!==i&&"object"==typeof i&&!n(i)){for(let r in i)if(Object.prototype.hasOwnProperty.call(i,r)&&A[r])return k(t,e,i,!0)}for(let t of s)if(k({k:t},"k",i))return!0;return!1}if(null!==i&&"object"==typeof i&&!n(i)&&!Array.isArray(i)){let t=Object.keys(i),e=t.map(t=>t[0]),r=e.filter(t=>"$"===t);if(0!==r.length&&r.length!==e.length)throw Error("You cannot mix operators and normal fields");if(r.length>0){for(let e of t){if(!w[e])throw Error(`Unknown comparison function ${e}`);if(!w[e](s,i[e]))return!1}return!0}}return n(i)?w.$regex(s,i):m(s,i)}e.exports.serialize=t=>JSON.stringify(t,function(t,e){if(a(t,e),void 0!==e)return null===e?null:"function"==typeof this[t].getTime?{$$date:this[t].getTime()}:e}),e.exports.deserialize=t=>JSON.parse(t,function(t,e){return"$$date"===t?new Date(e):"string"==typeof e||"number"==typeof e||"boolean"==typeof e||null===e?e:e&&e.$$date?e.$$date:e}),e.exports.deepCopy=h,e.exports.checkObject=o,e.exports.isPrimitiveType=l,e.exports.modify=(t,e)=>{let i,s,n=Object.keys(e),a=n.map(t=>t[0]),l=a.filter(t=>"$"===t);if(-1!==n.indexOf("_id")&&e._id!==t._id)throw Error("You cannot change a document's _id");if(0!==l.length&&l.length!==a.length)throw Error("You cannot mix modifiers and normal fields");if(0===l.length?(i=h(e))._id=t._id:(s=r(n),i=h(t),s.forEach(t=>{if(!f[t])throw Error(`Unknown modifier ${t}`);if("object"!=typeof e[t])throw Error(`Modifier ${t}'s argument must be an object`);Object.keys(e[t]).forEach(r=>{f[t](i,r,e[t][r])})})),o(i),t._id!==i._id)throw Error("You can't change a document's _id");return i},e.exports.getDotValue=g,e.exports.getDotValues=(t,e)=>{if(!Array.isArray(e))throw Error("fields must be an Array");if(!(e.length>1))return g(t,e[0]);{let i={};for(let r of e)i[r]=g(t,r);return i}},e.exports.match=P,e.exports.areThingsEqual=m,e.exports.compareThings=u},85155,(t,e,i)=>{let r=t.r(39637),{callbackify:s}=t.r(24361);e.exports=class{constructor(t,e,i){this.db=t,this.query=e||{},i&&(this.mapFn=i),this._limit=void 0,this._skip=void 0,this._sort=void 0,this._projection=void 0}limit(t){return this._limit=t,this}skip(t){return this._skip=t,this}sort(t){return this._sort=t,this}projection(t){return this._projection=t,this}_project(t){let e,i=[];if(void 0===this._projection||0===Object.keys(this._projection).length)return t;let s=0!==this._projection._id,{_id:n,...a}=this._projection;this._projection=a;let o=Object.keys(this._projection);return o.forEach(t=>{if(void 0!==e&&this._projection[t]!==e)throw Error("Can't both keep and omit fields except for _id");e=this._projection[t]}),t.forEach(t=>{let n;1===e?(n={$set:{}},o.forEach(e=>{n.$set[e]=r.getDotValue(t,e),void 0===n.$set[e]&&delete n.$set[e]}),n=r.modify({},n)):(n={$unset:{}},o.forEach(t=>{n.$unset[t]=!0}),n=r.modify(t,n)),s?n._id=t._id:delete n._id,i.push(n)}),i}async _execAsync(){let t=[],e=0,i=0;for(let s of(await this.db._getCandidatesAsync(this.query)))if(r.match(s,this.query)){if(this._sort)t.push(s);else if(this._skip&&this._skip>i)i+=1;else if(t.push(s),e+=1,this._limit&&this._limit<=e)break}if(this._sort){let e=Object.entries(this._sort).map(([t,e])=>({key:t,direction:e}));t.sort((t,i)=>{for(let s of e){let e=s.direction*r.compareThings(r.getDotValue(t,s.key),r.getDotValue(i,s.key),this.db.compareStrings);if(0!==e)return e}return 0});let i=this._limit||t.length,s=this._skip||0;t=t.slice(s,s+i)}return(t=this._project(t),this.mapFn)?this.mapFn(t):t}exec(t){s(()=>this.execAsync())(t)}execAsync(){return this.db.executor.pushAsync(()=>this._execAsync())}then(t,e){return this.execAsync().then(t,e)}catch(t){return this.execAsync().catch(t)}finally(t){return this.execAsync().finally(t)}}},98814,(t,e,i)=>{let r=t.r(54799);e.exports.uid=t=>r.randomBytes(Math.ceil(Math.max(8,2*t))).toString("base64").replace(/[+/]/g,"").slice(0,t)},39401,(t,e,i)=>{e.exports=class{constructor(){this.guardian=Promise.resolve()}waterfall(t){return(...e)=>(this.guardian=this.guardian.then(()=>t(...e).then(t=>({error:!1,result:t}),t=>({error:!0,result:t}))),this.guardian.then(({error:t,result:e})=>t?Promise.reject(e):Promise.resolve(e)))}chain(t){return this.waterfall(()=>t)()}}},14768,(t,e,i)=>{let r=t.r(39401);e.exports=class{constructor(){this.ready=!1,this.queue=new r,this.buffer=null,this._triggerBuffer=null,this.resetBuffer()}pushAsync(t,e=!1){return this.ready||e?this.queue.waterfall(t)():this.buffer.waterfall(t)()}processBuffer(){this.ready=!0,this._triggerBuffer(),this.queue.waterfall(()=>this.buffer.guardian)}resetBuffer(){this.buffer=new r,this.buffer.chain(new Promise(t=>{this._triggerBuffer=t})),this.ready&&this._triggerBuffer()}}},95936,(t,e,i)=>{let r=t=>{if(0===t)return[];if(1===t)return[0];let e=r(t-1),i=Math.floor(Math.random()*t);return e.splice(i,0,t-1),e};e.exports.getRandomArray=r,e.exports.defaultCompareKeysFunction=(t,e)=>{if(t<e)return -1;if(t>e)return 1;if(t===e)return 0;let i=Error("Couldn't compare elements");throw i.a=t,i.b=e,i},e.exports.defaultCheckValueEquality=(t,e)=>t===e},9791,(t,e,i)=>{let r=t.r(95936);function s(t,e){for(let i=0;i<e.length;i+=1)t.push(e[i])}e.exports=class{constructor(t){t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,Object.prototype.hasOwnProperty.call(t,"key")&&(this.key=t.key),this.data=Object.prototype.hasOwnProperty.call(t,"value")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||r.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||r.defaultCheckValueEquality}getMaxKeyDescendant(){return this.right?this.right.getMaxKeyDescendant():this}getMaxKey(){return this.getMaxKeyDescendant().key}getMinKeyDescendant(){return this.left?this.left.getMinKeyDescendant():this}getMinKey(){return this.getMinKeyDescendant().key}checkAllNodesFullfillCondition(t){Object.prototype.hasOwnProperty.call(this,"key")&&(t(this.key,this.data),this.left&&this.left.checkAllNodesFullfillCondition(t),this.right&&this.right.checkAllNodesFullfillCondition(t))}checkNodeOrdering(){Object.prototype.hasOwnProperty.call(this,"key")&&(this.left&&(this.left.checkAllNodesFullfillCondition(t=>{if(this.compareKeys(t,this.key)>=0)throw Error(`Tree with root ${this.key} is not a binary search tree`)}),this.left.checkNodeOrdering()),this.right&&(this.right.checkAllNodesFullfillCondition(t=>{if(0>=this.compareKeys(t,this.key))throw Error(`Tree with root ${this.key} is not a binary search tree`)}),this.right.checkNodeOrdering()))}checkInternalPointers(){if(this.left){if(this.left.parent!==this)throw Error(`Parent pointer broken for key ${this.key}`);this.left.checkInternalPointers()}if(this.right){if(this.right.parent!==this)throw Error(`Parent pointer broken for key ${this.key}`);this.right.checkInternalPointers()}}checkIsBST(){if(this.checkNodeOrdering(),this.checkInternalPointers(),this.parent)throw Error("The root shouldn't have a parent")}getNumberOfKeys(){let t;return Object.prototype.hasOwnProperty.call(this,"key")?(t=1,this.left&&(t+=this.left.getNumberOfKeys()),this.right&&(t+=this.right.getNumberOfKeys()),t):0}createSimilar(t){return(t=t||{}).unique=this.unique,t.compareKeys=this.compareKeys,t.checkValueEquality=this.checkValueEquality,new this.constructor(t)}createLeftChild(t){let e=this.createSimilar(t);return e.parent=this,this.left=e,e}createRightChild(t){let e=this.createSimilar(t);return e.parent=this,this.right=e,e}insert(t,e){if(!Object.prototype.hasOwnProperty.call(this,"key")){this.key=t,this.data.push(e);return}if(0===this.compareKeys(this.key,t)){if(this.unique){let e=Error(`Can't insert key ${JSON.stringify(t)}, it violates the unique constraint`);throw e.key=t,e.errorType="uniqueViolated",e}this.data.push(e);return}0>this.compareKeys(t,this.key)?this.left?this.left.insert(t,e):this.createLeftChild({key:t,value:e}):this.right?this.right.insert(t,e):this.createRightChild({key:t,value:e})}search(t){if(!Object.prototype.hasOwnProperty.call(this,"key"))return[];if(0===this.compareKeys(this.key,t))return this.data;if(0>this.compareKeys(t,this.key))if(this.left)return this.left.search(t);else return[];return this.right?this.right.search(t):[]}getLowerBoundMatcher(t){return Object.prototype.hasOwnProperty.call(t,"$gt")||Object.prototype.hasOwnProperty.call(t,"$gte")?Object.prototype.hasOwnProperty.call(t,"$gt")&&Object.prototype.hasOwnProperty.call(t,"$gte")?0===this.compareKeys(t.$gte,t.$gt)?e=>this.compareKeys(e,t.$gt)>0:this.compareKeys(t.$gte,t.$gt)>0?e=>this.compareKeys(e,t.$gte)>=0:e=>this.compareKeys(e,t.$gt)>0:Object.prototype.hasOwnProperty.call(t,"$gt")?e=>this.compareKeys(e,t.$gt)>0:e=>this.compareKeys(e,t.$gte)>=0:()=>!0}getUpperBoundMatcher(t){return Object.prototype.hasOwnProperty.call(t,"$lt")||Object.prototype.hasOwnProperty.call(t,"$lte")?Object.prototype.hasOwnProperty.call(t,"$lt")&&Object.prototype.hasOwnProperty.call(t,"$lte")?0===this.compareKeys(t.$lte,t.$lt)?e=>0>this.compareKeys(e,t.$lt):0>this.compareKeys(t.$lte,t.$lt)?e=>0>=this.compareKeys(e,t.$lte):e=>0>this.compareKeys(e,t.$lt):Object.prototype.hasOwnProperty.call(t,"$lt")?e=>0>this.compareKeys(e,t.$lt):e=>0>=this.compareKeys(e,t.$lte):()=>!0}betweenBounds(t,e,i){let r=[];return Object.prototype.hasOwnProperty.call(this,"key")?(e=e||this.getLowerBoundMatcher(t),i=i||this.getUpperBoundMatcher(t),e(this.key)&&this.left&&s(r,this.left.betweenBounds(t,e,i)),e(this.key)&&i(this.key)&&s(r,this.data),i(this.key)&&this.right&&s(r,this.right.betweenBounds(t,e,i)),r):[]}deleteIfLeaf(){return!this.left&&!this.right&&(this.parent?this.parent.left===this?this.parent.left=null:this.parent.right=null:(delete this.key,this.data=[]),!0)}deleteIfOnlyOneChild(){let t;return this.left&&!this.right&&(t=this.left),!this.left&&this.right&&(t=this.right),!!t&&(this.parent?(this.parent.left===this?this.parent.left=t:this.parent.right=t,t.parent=this.parent):(this.key=t.key,this.data=t.data,this.left=null,t.left&&(this.left=t.left,t.left.parent=this),this.right=null,t.right&&(this.right=t.right,t.right.parent=this)),!0)}delete(t,e){let i,r=[];if(Object.prototype.hasOwnProperty.call(this,"key")){if(0>this.compareKeys(t,this.key)){this.left&&this.left.delete(t,e);return}if(this.compareKeys(t,this.key)>0){this.right&&this.right.delete(t,e);return}if(this.compareKeys(t,this.key),this.data.length>1&&void 0!==e){this.data.forEach(t=>{this.checkValueEquality(t,e)||r.push(t)}),this.data=r;return}this.deleteIfLeaf()||!this.deleteIfOnlyOneChild()&&(Math.random()>=.5?(i=this.left.getMaxKeyDescendant(),this.key=i.key,this.data=i.data,this===i.parent?this.left=i.left:i.parent.right=i.left,i.left&&(i.left.parent=i.parent)):(i=this.right.getMinKeyDescendant(),this.key=i.key,this.data=i.data,this===i.parent?this.right=i.right:i.parent.left=i.right,i.right&&(i.right.parent=i.parent)))}}executeOnEveryNode(t){this.left&&this.left.executeOnEveryNode(t),t(this),this.right&&this.right.executeOnEveryNode(t)}prettyPrint(t,e){e=e||"",console.log(`${e}* ${this.key}`),t&&console.log(`${e}* ${this.data}`),(this.left||this.right)&&(this.left?this.left.prettyPrint(t,`${e}  `):console.log(`${e}  *`),this.right?this.right.prettyPrint(t,`${e}  `):console.log(`${e}  *`))}}},83151,(t,e,i)=>{let r=t.r(9791),s=t.r(95936);class n{constructor(t){this.tree=new a(t)}checkIsAVLT(){this.tree.checkIsAVLT()}insert(t,e){let i=this.tree.insert(t,e);i&&(this.tree=i)}delete(t,e){let i=this.tree.delete(t,e);i&&(this.tree=i)}}class a extends r{constructor(t){super(),t=t||{},this.left=null,this.right=null,this.parent=void 0!==t.parent?t.parent:null,Object.prototype.hasOwnProperty.call(t,"key")&&(this.key=t.key),this.data=Object.prototype.hasOwnProperty.call(t,"value")?[t.value]:[],this.unique=t.unique||!1,this.compareKeys=t.compareKeys||s.defaultCompareKeysFunction,this.checkValueEquality=t.checkValueEquality||s.defaultCheckValueEquality}checkHeightCorrect(){if(!Object.prototype.hasOwnProperty.call(this,"key"))return;if(this.left&&void 0===this.left.height)throw Error("Undefined height for node "+this.left.key);if(this.right&&void 0===this.right.height)throw Error("Undefined height for node "+this.right.key);if(void 0===this.height)throw Error("Undefined height for node "+this.key);let t=this.left?this.left.height:0,e=this.right?this.right.height:0;if(this.height!==1+Math.max(t,e))throw Error("Height constraint failed for node "+this.key);this.left&&this.left.checkHeightCorrect(),this.right&&this.right.checkHeightCorrect()}balanceFactor(){return(this.left?this.left.height:0)-(this.right?this.right.height:0)}checkBalanceFactors(){if(Math.abs(this.balanceFactor())>1)throw Error("Tree is unbalanced at node "+this.key);this.left&&this.left.checkBalanceFactors(),this.right&&this.right.checkBalanceFactors()}checkIsAVLT(){super.checkIsBST(),this.checkHeightCorrect(),this.checkBalanceFactors()}rightRotation(){let t=this.left;if(!t)return this;let e=t.right;this.parent?(t.parent=this.parent,this.parent.left===this?this.parent.left=t:this.parent.right=t):t.parent=null,t.right=this,this.parent=t,this.left=e,e&&(e.parent=this);let i=t.left?t.left.height:0,r=e?e.height:0,s=this.right?this.right.height:0;return this.height=Math.max(r,s)+1,t.height=Math.max(i,this.height)+1,t}leftRotation(){let t=this.right;if(!t)return this;let e=t.left;this.parent?(t.parent=this.parent,this.parent.left===this?this.parent.left=t:this.parent.right=t):t.parent=null,t.left=this,this.parent=t,this.right=e,e&&(e.parent=this);let i=this.left?this.left.height:0,r=e?e.height:0,s=t.right?t.right.height:0;return this.height=Math.max(i,r)+1,t.height=Math.max(s,this.height)+1,t}rightTooSmall(){return 1>=this.balanceFactor()?this:(0>this.left.balanceFactor()&&this.left.leftRotation(),this.rightRotation())}leftTooSmall(){return this.balanceFactor()>=-1?this:(this.right.balanceFactor()>0&&this.right.rightRotation(),this.leftRotation())}rebalanceAlongPath(t){let e,i,r=this;if(!Object.prototype.hasOwnProperty.call(this,"key"))return delete this.height,this;for(i=t.length-1;i>=0;i-=1)t[i].height=1+Math.max(t[i].left?t[i].left.height:0,t[i].right?t[i].right.height:0),t[i].balanceFactor()>1&&(e=t[i].rightTooSmall(),0===i&&(r=e)),-1>t[i].balanceFactor()&&(e=t[i].leftTooSmall(),0===i&&(r=e));return r}insert(t,e){let i=[],r=this;if(!Object.prototype.hasOwnProperty.call(this,"key"))return this.key=t,this.data.push(e),this.height=1,this;for(;;){if(0===r.compareKeys(r.key,t)){if(r.unique){let e=Error(`Can't insert key ${JSON.stringify(t)}, it violates the unique constraint`);throw e.key=t,e.errorType="uniqueViolated",e}return r.data.push(e),this}if(i.push(r),0>r.compareKeys(t,r.key))if(r.left)r=r.left;else{i.push(r.createLeftChild({key:t,value:e}));break}else if(r.right)r=r.right;else{i.push(r.createRightChild({key:t,value:e}));break}}return this.rebalanceAlongPath(i)}delete(t,e){let i,r=[],s=this,n=[];if(!Object.prototype.hasOwnProperty.call(this,"key"))return this;for(;0!==s.compareKeys(t,s.key);)if(n.push(s),0>s.compareKeys(t,s.key))if(!s.left)return this;else s=s.left;else{if(!s.right)return this;s=s.right}if(s.data.length>1&&void 0!==e)return s.data.forEach(function(t){s.checkValueEquality(t,e)||r.push(t)}),s.data=r,this;if(!s.left&&!s.right)if(s===this)return delete s.key,s.data=[],delete s.height,this;else return s.parent.left===s?s.parent.left=null:s.parent.right=null,this.rebalanceAlongPath(n);if(!s.left||!s.right)return(i=s.left?s.left:s.right,s===this)?(i.parent=null,i):(s.parent.left===s?s.parent.left=i:s.parent.right=i,i.parent=s.parent,this.rebalanceAlongPath(n));if(n.push(s),!(i=s.left).right)return s.key=i.key,s.data=i.data,s.left=i.left,i.left&&(i.left.parent=s),this.rebalanceAlongPath(n);for(;;)if(i.right)n.push(i),i=i.right;else break;return s.key=i.key,s.data=i.data,i.parent.right=i.left,i.left&&(i.left.parent=i.parent),this.rebalanceAlongPath(n)}}n._AVLTree=a,["getNumberOfKeys","search","betweenBounds","prettyPrint","executeOnEveryNode"].forEach(function(t){n.prototype[t]=function(){return this.tree[t].apply(this.tree,arguments)}}),e.exports=n},85519,(t,e,i)=>{e.exports.BinarySearchTree=t.r(9791),e.exports.AVLTree=t.r(83151)},80169,(t,e,i)=>{let r=t.r(85519).AVLTree,s=t.r(39637),{uniq:n,isDate:a}=t.r(41300),o=(t,e)=>t===e,h=t=>null===t?"$null":"string"==typeof t?"$string"+t:"boolean"==typeof t?"$boolean"+t:"number"==typeof t?"$number"+t:a(t)?"$date"+t.getTime():t;e.exports=class{constructor(t){if(this.fieldName=t.fieldName,"string"!=typeof this.fieldName)throw Error("fieldName must be a string");this._fields=this.fieldName.split(","),this.unique=t.unique||!1,this.sparse=t.sparse||!1,this.treeOptions={unique:this.unique,compareKeys:s.compareThings,checkValueEquality:o},this.tree=new r(this.treeOptions)}reset(t){this.tree=new r(this.treeOptions),t&&this.insert(t)}insert(t){let e,i,r;if(Array.isArray(t))return void this.insertMultipleDocs(t);let a=s.getDotValues(t,this._fields);if(!(void 0===a||"object"==typeof a&&null!==a&&Object.values(a).every(t=>void 0===t))||!this.sparse)if(Array.isArray(a)){e=n(a,h);for(let s=0;s<e.length;s+=1)try{this.tree.insert(e[s],t)}catch(t){r=t,i=s;break}if(r){for(let r=0;r<i;r+=1)this.tree.delete(e[r],t);throw r}}else this.tree.insert(a,t)}insertMultipleDocs(t){let e,i;for(let r=0;r<t.length;r+=1)try{this.insert(t[r])}catch(t){e=t,i=r;break}if(e){for(let e=0;e<i;e+=1)this.remove(t[e]);throw e}}remove(t){if(Array.isArray(t))return void t.forEach(t=>{this.remove(t)});let e=s.getDotValues(t,this._fields);void 0===e&&this.sparse||(Array.isArray(e)?n(e,h).forEach(e=>{this.tree.delete(e,t)}):this.tree.delete(e,t))}update(t,e){if(Array.isArray(t))return void this.updateMultipleDocs(t);this.remove(t);try{this.insert(e)}catch(e){throw this.insert(t),e}}updateMultipleDocs(t){let e,i;for(let e=0;e<t.length;e+=1)this.remove(t[e].oldDoc);for(let r=0;r<t.length;r+=1)try{this.insert(t[r].newDoc)}catch(t){i=t,e=r;break}if(i){for(let i=0;i<e;i+=1)this.remove(t[i].newDoc);for(let e=0;e<t.length;e+=1)this.insert(t[e].oldDoc);throw i}}revertUpdate(t,e){let i=[];Array.isArray(t)?(t.forEach(t=>{i.push({oldDoc:t.newDoc,newDoc:t.oldDoc})}),this.update(i)):this.update(e,t)}getMatching(t){if(!Array.isArray(t))return this.tree.search(t);{let e={},i=[];return t.forEach(t=>{this.getMatching(t).forEach(t=>{e[t._id]=t})}),Object.keys(e).forEach(t=>{i.push(e[t])}),i}}getBetweenBounds(t){return this.tree.betweenBounds(t)}getAll(){let t=[];return this.tree.executeOnEveryNode(e=>{t.push(...e.data)}),t}}},37464,(t,e,i)=>{e.exports=t.x("timers",()=>require("timers"))},874,(t,e,i)=>{e.exports=t.x("buffer",()=>require("buffer"))},42160,(t,e,i)=>{let r=t.r(88947),s=t.r(37464),{Buffer:n}=t.r(874);class a extends r.Transform{constructor(t){super(t),t=t||{},this._readableState.objectMode=!0,this._lineBuffer=[],this._keepEmptyLines=t.keepEmptyLines||!1,this._lastChunkEndedWithCR=!1,this.once("pipe",t=>{!this.encoding&&t instanceof r.Readable&&(this.encoding=t._readableState.encoding)})}_transform(t,e,i){e=e||"utf8",n.isBuffer(t)&&("buffer"===e?(t=t.toString(),e="utf8"):t=t.toString(e)),this._chunkEncoding=e;let r=t.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/g);this._lastChunkEndedWithCR&&"\n"===t[0]&&r.shift(),this._lineBuffer.length>0&&(this._lineBuffer[this._lineBuffer.length-1]+=r[0],r.shift()),this._lastChunkEndedWithCR="\r"===t[t.length-1],this._lineBuffer=this._lineBuffer.concat(r),this._pushBuffer(e,1,i)}_pushBuffer(t,e,i){for(;this._lineBuffer.length>e;){let r=this._lineBuffer.shift();if((this._keepEmptyLines||r.length>0)&&!this.push(this._reencode(r,t)))return void s.setImmediate(()=>{this._pushBuffer(t,e,i)})}i()}_flush(t){this._pushBuffer(this._chunkEncoding,0,t)}_reencode(t,e){return this.encoding&&this.encoding!==e?n.from(t,e).toString(this.encoding):this.encoding?t:n.from(t,e)}}e.exports=(t,e)=>{if(!t)throw Error("expected readStream");if(!t.readable)throw Error("readStream must be readable");let i=new a(e);return t.pipe(i),i}},69053,(t,e,i)=>{let r=t.r(22734),s=r.promises,n=t.r(14747),{Readable:a}=t.r(88947),o=493,h=420,l=t=>s.access(t,r.constants.F_OK).then(()=>!0,()=>!1),c=s.rename,d=s.writeFile,u=r.createWriteStream,p=s.unlink,y=s.appendFile,f=s.readFile,g=r.createReadStream,m=s.mkdir,b=async t=>{await l(t)&&await p(t)},w=async t=>{let e,i,r,n,a,o;"string"==typeof t?(e=t,i="r+",r=h):(e=t.filename,i=t.isDir?"r":"r+",r=void 0!==t.mode?t.mode:h);try{n=await s.open(e,i,r);try{await n.sync()}catch(t){a=t}}catch(e){if("EISDIR"!==e.code||!t.isDir)throw e}finally{try{await n.close()}catch(t){o=t}}if((a||o)&&!(("EPERM"===a.code||"EISDIR"===o.code)&&t.isDir)){let t=Error("Failed to flush to storage");throw t.errorOnFsync=a,t.errorOnClose=o,t}},A=(t,e,i=h)=>new Promise((r,s)=>{try{let n=u(t,{mode:i}),o=a.from(e);o.on("data",t=>{try{n.write(t+"\n")}catch(t){s(t)}}),o.on("end",()=>{n.close(t=>{t?s(t):r()})}),o.on("error",t=>{s(t)}),n.on("error",t=>{s(t)})}catch(t){s(t)}}),v=async(t,e,i={fileMode:h,dirMode:o})=>{let r=t+"~";await w({filename:n.dirname(t),isDir:!0,mode:i.dirMode}),await l(t)&&await w({filename:t,mode:i.fileMode}),await A(r,e,i.fileMode),await w({filename:r,mode:i.fileMode}),await c(r,t),await w({filename:n.dirname(t),isDir:!0,mode:i.dirMode})},P=async(t,e=h)=>{let i=t+"~";await l(t)||(await l(i)?await c(i,t):await d(t,"",{encoding:"utf8",mode:e}))},k=async(t,e)=>{let i=n.dirname(t);n.parse(n.resolve(i)),await m(i,{recursive:!0,mode:e})};e.exports.existsAsync=l,e.exports.renameAsync=c,e.exports.writeFileAsync=d,e.exports.writeFileLinesAsync=A,e.exports.crashSafeWriteFileLinesAsync=v,e.exports.appendFileAsync=y,e.exports.readFileAsync=f,e.exports.unlinkAsync=p,e.exports.mkdirAsync=m,e.exports.readFileStream=g,e.exports.flushToStorageAsync=w,e.exports.ensureDatafileIntegrityAsync=P,e.exports.ensureFileDoesntExistAsync=b,e.exports.ensureParentDirectoryExistsAsync=k},65610,(t,e,i)=>{let{deprecate:r}=t.r(24361),s=t.r(42160),n=t.r(80169),a=t.r(39637),o=t.r(69053),h=t.r(39401);class l{constructor(t){if(this.db=t.db,this.inMemoryOnly=this.db.inMemoryOnly,this.filename=this.db.filename,this.corruptAlertThreshold=void 0!==t.corruptAlertThreshold?t.corruptAlertThreshold:.1,this.modes=void 0!==t.modes?t.modes:{fileMode:420,dirMode:493},void 0===this.modes.fileMode&&(this.modes.fileMode=420),void 0===this.modes.dirMode&&(this.modes.dirMode=493),!this.inMemoryOnly&&this.filename&&"~"===this.filename.charAt(this.filename.length-1))throw Error("The datafile name can't end with a ~, which is reserved for crash safe backup files");if(t.afterSerialization&&!t.beforeDeserialization)throw Error("Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss");if(!t.afterSerialization&&t.beforeDeserialization)throw Error("Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss");this.afterSerialization=async e=>(t.afterSerialization||(t=>t))(e),this.beforeDeserialization=async e=>(t.beforeDeserialization||(t=>t))(e)}async persistCachedDatabaseAsync(){let t=[];if(!this.inMemoryOnly){for(let e of this.db.getAllData())t.push(await this.afterSerialization(a.serialize(e)));for(let e of Object.keys(this.db.indexes))"_id"!==e&&t.push(await this.afterSerialization(a.serialize({$$indexCreated:{fieldName:this.db.indexes[e].fieldName,unique:this.db.indexes[e].unique,sparse:this.db.indexes[e].sparse}})));await o.crashSafeWriteFileLinesAsync(this.filename,t,this.modes),this.db.emit("compaction.done")}}compactDatafile(t){r(t=>this.db.compactDatafile(t),"@seald-io/nedb: calling Datastore#persistence#compactDatafile is deprecated, please use Datastore#compactDatafile, it will be removed in the next major version.")(t)}setAutocompactionInterval(t){r(t=>this.db.setAutocompactionInterval(t),"@seald-io/nedb: calling Datastore#persistence#setAutocompactionInterval is deprecated, please use Datastore#setAutocompactionInterval, it will be removed in the next major version.")(t)}stopAutocompaction(){r(()=>this.db.stopAutocompaction(),"@seald-io/nedb: calling Datastore#persistence#stopAutocompaction is deprecated, please use Datastore#stopAutocompaction, it will be removed in the next major version.")()}async persistNewStateAsync(t){let e="";if(!this.inMemoryOnly){for(let i of t)e+=await this.afterSerialization(a.serialize(i))+"\n";0!==e.length&&await o.appendFileAsync(this.filename,e,{encoding:"utf8",mode:this.modes.fileMode})}}async treatRawData(t){let e=t.split("\n").filter(t=>""!==t).map(async t=>a.deserialize(await this.beforeDeserialization(t))),i={},r={},s=e.length,n=0;for(let t of e)try{let e=await t;e._id?!0===e.$$deleted?delete i[e._id]:i[e._id]=e:e.$$indexCreated&&null!=e.$$indexCreated.fieldName?r[e.$$indexCreated.fieldName]=e.$$indexCreated:"string"==typeof e.$$indexRemoved&&delete r[e.$$indexRemoved]}catch(t){n+=1}if(s>0){let t=n/s;if(t>this.corruptAlertThreshold){let e=Error(`${Math.floor(100*t)}% of the data file is corrupt, more than given corruptAlertThreshold (${Math.floor(100*this.corruptAlertThreshold)}%). Cautiously refusing to start NeDB to prevent dataloss.`);throw e.corruptionRate=t,e.corruptItems=n,e.dataLength=s,e}}return{data:Object.values(i),indexes:r}}treatRawStreamAsync(t){return new Promise((e,i)=>{let r={},n={},o=0,l=s(t),c=0,d=new h;l.on("data",t=>{let e=this.beforeDeserialization(t);return d.waterfall(async()=>{if(""!==t){try{let t=a.deserialize(await e);t._id?!0===t.$$deleted?delete r[t._id]:r[t._id]=t:t.$$indexCreated&&null!=t.$$indexCreated.fieldName?n[t.$$indexCreated.fieldName]=t.$$indexCreated:"string"==typeof t.$$indexRemoved&&delete n[t.$$indexRemoved]}catch(t){o+=1}c++}})()}),l.on("end",async()=>{if(await d.guardian,c>0){let t=o/c;if(t>this.corruptAlertThreshold){let e=Error(`${Math.floor(100*t)}% of the data file is corrupt, more than given corruptAlertThreshold (${Math.floor(100*this.corruptAlertThreshold)}%). Cautiously refusing to start NeDB to prevent dataloss.`);e.corruptionRate=t,e.corruptItems=o,e.dataLength=c,i(e,null);return}}e({data:Object.values(r),indexes:n})}),l.on("error",function(t){i(t,null)})})}async loadDatabaseAsync(){let t;if(this.db._resetIndexes(),!this.inMemoryOnly){if(await l.ensureParentDirectoryExistsAsync(this.filename,this.modes.dirMode),await o.ensureDatafileIntegrityAsync(this.filename,this.modes.fileMode),o.readFileStream){let e=o.readFileStream(this.filename,{encoding:"utf8",mode:this.modes.fileMode});t=await this.treatRawStreamAsync(e)}else{let e=await o.readFileAsync(this.filename,{encoding:"utf8",mode:this.modes.fileMode});t=await this.treatRawData(e)}Object.keys(t.indexes).forEach(e=>{this.db.indexes[e]=new n(t.indexes[e])});try{this.db._resetIndexes(t.data)}catch(t){throw this.db._resetIndexes(),t}await this.db.persistence.persistCachedDatabaseAsync(),this.db.executor.processBuffer()}}async dropDatabaseAsync(){this.db.stopAutocompaction(),this.db.executor.ready=!1,this.db.executor.resetBuffer(),await this.db.executor.queue.guardian,this.db.indexes={},this.db.indexes._id=new n({fieldName:"_id",unique:!0}),this.db.ttlIndexes={},this.db.inMemoryOnly||await this.db.executor.pushAsync(async()=>{await o.existsAsync(this.filename)&&await o.unlinkAsync(this.filename)},!0)}static async ensureParentDirectoryExistsAsync(t,e=493){return o.ensureParentDirectoryExistsAsync(t,e)}}e.exports=l},31264,(t,e,i)=>{let{EventEmitter:r}=t.r(27699),{callbackify:s,deprecate:n}=t.r(24361),a=t.r(85155),o=t.r(98814),h=t.r(14768),l=t.r(80169),c=t.r(39637),d=t.r(65610),{isDate:u,pick:p,filterIndexNames:y}=t.r(41300);e.exports=class extends r{constructor(t){let e;super(),"string"==typeof t?n(()=>{e=t,this.inMemoryOnly=!1},"@seald-io/nedb: Giving a string to the Datastore constructor is deprecated and will be removed in the next major version. Please use an options object with an argument 'filename'.")():(e=(t=t||{}).filename,this.inMemoryOnly=t.inMemoryOnly||!1,this.autoload=t.autoload||!1,this.timestampData=t.timestampData||!1),e&&"string"==typeof e&&0!==e.length?this.filename=e:(this.filename=null,this.inMemoryOnly=!0),this.compareStrings=t.compareStrings,this.persistence=new d({db:this,afterSerialization:t.afterSerialization,beforeDeserialization:t.beforeDeserialization,corruptAlertThreshold:t.corruptAlertThreshold,modes:t.modes,testSerializationHooks:t.testSerializationHooks}),this.executor=new h,this.inMemoryOnly&&(this.executor.ready=!0),this.indexes={},this.indexes._id=new l({fieldName:"_id",unique:!0}),this.ttlIndexes={},this.autoload?(this.autoloadPromise=this.loadDatabaseAsync(),this.autoloadPromise.then(()=>{t.onload&&t.onload()},e=>{if(t.onload)t.onload(e);else throw e})):this.autoloadPromise=null,this._autocompactionIntervalId=null}compactDatafileAsync(){return this.executor.pushAsync(()=>this.persistence.persistCachedDatabaseAsync())}compactDatafile(t){let e=this.compactDatafileAsync();"function"==typeof t&&s(()=>e)(t)}setAutocompactionInterval(t){if(Number.isNaN(Number(t)))throw Error("Interval must be a non-NaN number");let e=Math.max(Number(t),5e3);this.stopAutocompaction(),this._autocompactionIntervalId=setInterval(()=>{this.compactDatafile()},e)}stopAutocompaction(){this._autocompactionIntervalId&&(clearInterval(this._autocompactionIntervalId),this._autocompactionIntervalId=null)}loadDatabase(t){let e=this.loadDatabaseAsync();"function"==typeof t&&s(()=>e)(t)}dropDatabaseAsync(){return this.persistence.dropDatabaseAsync()}dropDatabase(t){let e=this.dropDatabaseAsync();"function"==typeof t&&s(()=>e)(t)}loadDatabaseAsync(){return this.executor.pushAsync(()=>this.persistence.loadDatabaseAsync(),!0)}getAllData(){return this.indexes._id.getAll()}_resetIndexes(t){for(let e of Object.values(this.indexes))e.reset(t)}ensureIndex(t={},e){let i=this.ensureIndexAsync(t);"function"==typeof e&&s(()=>i)(e)}async ensureIndexAsync(t={}){if(!t.fieldName){let t=Error("Cannot create an index without a fieldName");throw t.missingFieldName=!0,t}let e=[].concat(t.fieldName).sort();if(e.some(t=>t.includes(",")))throw Error("Cannot use comma in index fieldName");let i={...t,fieldName:e.join(",")};if(!this.indexes[i.fieldName]){this.indexes[i.fieldName]=new l(i),void 0!==t.expireAfterSeconds&&(this.ttlIndexes[i.fieldName]=i.expireAfterSeconds);try{this.indexes[i.fieldName].insert(this.getAllData())}catch(t){throw delete this.indexes[i.fieldName],t}await this.executor.pushAsync(()=>this.persistence.persistNewStateAsync([{$$indexCreated:i}]),!0)}}removeIndex(t,e=()=>{}){let i=this.removeIndexAsync(t);s(()=>i)(e)}async removeIndexAsync(t){delete this.indexes[t],await this.executor.pushAsync(()=>this.persistence.persistNewStateAsync([{$$indexRemoved:t}]),!0)}_addToIndexes(t){let e,i,r=Object.keys(this.indexes);for(let s=0;s<r.length;s+=1)try{this.indexes[r[s]].insert(t)}catch(t){e=s,i=t;break}if(i){for(let i=0;i<e;i+=1)this.indexes[r[i]].remove(t);throw i}}_removeFromIndexes(t){for(let e of Object.values(this.indexes))e.remove(t)}_updateIndexes(t,e){let i,r,s=Object.keys(this.indexes);for(let n=0;n<s.length;n+=1)try{this.indexes[s[n]].update(t,e)}catch(t){i=n,r=t;break}if(r){for(let r=0;r<i;r+=1)this.indexes[s[r]].revertUpdate(t,e);throw r}}_getRawCandidates(t){let e,i=Object.keys(this.indexes);if(e=Object.entries(t).filter(y(i)).pop())return this.indexes[e[0]].getMatching(e[1]);let r=i.filter(t=>-1!==t.indexOf(",")).map(t=>t.split(",")).filter(e=>Object.entries(t).filter(y(e)).length===e.length);return r.length>0?this.indexes[r[0]].getMatching(p(t,r[0])):(e=Object.entries(t).filter(([e,r])=>!!(t[e]&&Object.prototype.hasOwnProperty.call(t[e],"$in"))&&i.includes(e)).pop())?this.indexes[e[0]].getMatching(e[1].$in):(e=Object.entries(t).filter(([e,r])=>!!(t[e]&&(Object.prototype.hasOwnProperty.call(t[e],"$lt")||Object.prototype.hasOwnProperty.call(t[e],"$lte")||Object.prototype.hasOwnProperty.call(t[e],"$gt")||Object.prototype.hasOwnProperty.call(t[e],"$gte")))&&i.includes(e)).pop())?this.indexes[e[0]].getBetweenBounds(e[1]):this.getAllData()}async _getCandidatesAsync(t,e=!1){let i=[],r=this._getRawCandidates(t);if(e)i.push(...r);else{let t=[],e=Object.keys(this.ttlIndexes);for(let s of(r.forEach(r=>{e.every(t=>!(void 0!==r[t]&&u(r[t])&&Date.now()>r[t].getTime()+1e3*this.ttlIndexes[t]))?i.push(r):t.push(r._id)}),t))await this._removeAsync({_id:s},{})}return i}async _insertAsync(t){let e=this._prepareDocumentForInsertion(t);return this._insertInCache(e),await this.persistence.persistNewStateAsync(Array.isArray(e)?e:[e]),c.deepCopy(e)}_createNewId(){let t=o.uid(16);return this.indexes._id.getMatching(t).length>0&&(t=this._createNewId()),t}_prepareDocumentForInsertion(t){let e;if(Array.isArray(t))e=[],t.forEach(t=>{e.push(this._prepareDocumentForInsertion(t))});else{void 0===(e=c.deepCopy(t))._id&&(e._id=this._createNewId());let i=new Date;this.timestampData&&void 0===e.createdAt&&(e.createdAt=i),this.timestampData&&void 0===e.updatedAt&&(e.updatedAt=i),c.checkObject(e)}return e}_insertInCache(t){Array.isArray(t)?this._insertMultipleDocsInCache(t):this._addToIndexes(t)}_insertMultipleDocsInCache(t){let e,i;for(let r=0;r<t.length;r+=1)try{this._addToIndexes(t[r])}catch(t){i=t,e=r;break}if(i){for(let i=0;i<e;i+=1)this._removeFromIndexes(t[i]);throw i}}insert(t,e){let i=this.insertAsync(t);"function"==typeof e&&s(()=>i)(e)}insertAsync(t){return this.executor.pushAsync(()=>this._insertAsync(t))}count(t,e){let i=this.countAsync(t);if("function"!=typeof e)return i;s(i.execAsync.bind(i))(e)}countAsync(t){return new a(this,t,t=>t.length)}find(t,e,i){1==arguments.length?e={}:2==arguments.length&&"function"==typeof e&&(i=e,e={});let r=this.findAsync(t,e);if("function"!=typeof i)return r;s(r.execAsync.bind(r))(i)}findAsync(t,e={}){let i=new a(this,t,t=>t.map(t=>c.deepCopy(t)));return i.projection(e),i}findOne(t,e,i){1==arguments.length?e={}:2==arguments.length&&"function"==typeof e&&(i=e,e={});let r=this.findOneAsync(t,e);if("function"!=typeof i)return r;s(r.execAsync.bind(r))(i)}findOneAsync(t,e={}){let i=new a(this,t,t=>1===t.length?c.deepCopy(t[0]):null);return i.projection(e).limit(1),i}async _updateAsync(t,e,i){let r,s,n=void 0!==i.multi&&i.multi;if(void 0!==i.upsert&&i.upsert){let i=new a(this,t);if(1!==(await i.limit(1)._execAsync()).length){let i;try{c.checkObject(e),i=e}catch(r){i=c.modify(c.deepCopy(t,!0),e)}return{numAffected:1,affectedDocuments:await this._insertAsync(i),upsert:!0}}}let o=0,h=[];for(let i of(await this._getCandidatesAsync(t)))c.match(i,t)&&(n||0===o)&&(o+=1,this.timestampData&&(s=i.createdAt),r=c.modify(i,e),this.timestampData&&(r.createdAt=s,r.updatedAt=new Date),h.push({oldDoc:i,newDoc:r}));this._updateIndexes(h);let l=h.map(t=>t.newDoc);if(await this.persistence.persistNewStateAsync(l),!i.returnUpdatedDocs)return{numAffected:o,upsert:!1,affectedDocuments:null};{let t=[];return l.forEach(e=>{t.push(c.deepCopy(e))}),n||(t=t[0]),{numAffected:o,affectedDocuments:t,upsert:!1}}}update(t,e,i,r){"function"==typeof i&&(r=i,i={}),s((t,e,i)=>this.updateAsync(t,e,i))(t,e,i,(t,e={})=>{r&&r(t,e.numAffected,e.affectedDocuments,e.upsert)})}updateAsync(t,e,i={}){return this.executor.pushAsync(()=>this._updateAsync(t,e,i))}async _removeAsync(t,e={}){let i=void 0!==e.multi&&e.multi,r=await this._getCandidatesAsync(t,!0),s=[],n=0;return r.forEach(e=>{c.match(e,t)&&(i||0===n)&&(n+=1,s.push({$$deleted:!0,_id:e._id}),this._removeFromIndexes(e))}),await this.persistence.persistNewStateAsync(s),n}remove(t,e,i){"function"==typeof e&&(i=e,e={});let r=i||(()=>{});s((t,e)=>this.removeAsync(t,e))(t,e,r)}removeAsync(t,e={}){return this.executor.pushAsync(()=>this._removeAsync(t,e))}}},10529,(t,e,i)=>{e.exports=t.r(31264)},2157,(t,e,i)=>{e.exports=t.x("node:fs",()=>require("node:fs"))},75792,95807,t=>{"use strict";var e=t.i(60526),i=t.i(50227),r=t.i(10529);let s=class{db;wallet;seed=null;constructor(t){const e=t.db;this.db=new t.Datastore({filename:`${e}/keys.db`,autoload:!0}),this.wallet=t.wallet}setSeed(t){this.seed=t}getSeed(){return this.seed}sign(t){return this.wallet.sign(t.message,t.key,t.encoding)}encrypt(t){return this.wallet.encrypt(t.message,t.key)}decrypt(t){return this.wallet.decrypt(t.ciphertext,t.key)}async findOrCreate(t){let e=await this.findOne(t);if(!e){let i=this.seed;if(!i)return null;{let r=await this.wallet.createType42(i,t.host);e=await this.insert(r)}}return e}findOne(t){return new Promise(e=>{this.db.findOne(t,(t,i)=>{i?e(this.transform(i)):e(null)})})}find(t){return new Promise(e=>{this.db.find(t,(t,i)=>{e(i.map(t=>this.transform(t)))})})}count(t){return new Promise(e=>{this.db.count(t,(t,i)=>{e(i)})})}insert(t){return new Promise(e=>{this.db.insert(t,()=>{e(this.transform(t))})})}transform(t){let e=this.seed;if(!e)throw Error("Seed not set - wallet is locked");let i=this.wallet.deriveType42(e,t.path);return{...t,priv:i.privateKey.toWif(),pub:i.publicKey.toString(),address:i.publicKey.toAddress()}}all(){return new Promise(t=>{this.db.find({},(e,i)=>{t(i.map(t=>this.transform(t)))})})}};var n=t.i(2157);t.i(79549);var a=t.i(34908),o=t.i(83745),{toArray:h,toBase64:l}=o.Utils;async function c(t,e,i=6e5){let r=Uint8Array.from(h(t,"utf8")),s=await globalThis.crypto.subtle.importKey("raw",r,{name:"PBKDF2"},!1,["deriveKey"]);return globalThis.crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:i,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function d(t,e,i){let r=globalThis.crypto.getRandomValues(new Uint8Array(16)),s=globalThis.crypto.getRandomValues(new Uint8Array(12)),n=await c(e,r,i),a=JSON.stringify({...t,createdAt:t.createdAt||new Date().toISOString()}),o=new TextEncoder().encode(a),h=await globalThis.crypto.subtle.encrypt({name:"AES-GCM",iv:s},n,o),d=new Uint8Array(r.length+s.length+h.byteLength);return d.set(r,0),d.set(s,r.length),d.set(new Uint8Array(h),r.length+s.length),l(Array.from(d))}async function u(t,e,i){let r;try{r=h(t,"base64")}catch(t){throw console.error("Failed to decode base64 string (toArray threw):",t),Error("Decryption failed: Invalid Base64 input.")}if(t.length>0&&0===r.length)throw Error("Decryption failed: Invalid Base64 input (decoded to empty).");let s=Uint8Array.from(r);if(s.length<28)throw Error("Decryption failed: Encrypted data is too short.");let n=s.slice(0,16),a=s.slice(16,28),o=s.slice(28),l="number"==typeof i?[i]:Array.isArray(i)?i:[6e5,1e5],d=null;for(let t of l)try{let i=await c(e,n,t),r=await globalThis.crypto.subtle.decrypt({name:"AES-GCM",iv:a},i,o),s=new TextDecoder().decode(r);try{let t=JSON.parse(s);if("object"==typeof t&&null!==t&&("xprv"in t&&"ids"in t&&"mnemonic"in t||"rootPk"in t&&"ids"in t||"wif"in t&&"id"in t||"payPk"in t&&"ordPk"in t&&("mnemonic"in t||"payDerivationPath"in t||"ordDerivationPath"in t)||"chromeStorage"in t&&"accountData"in t||"ordPk"in t&&"payPk"in t&&"identityPk"in t||"encryptedVault"in t||"wif"in t&&!("id"in t)&&!("xprv"in t)&&!("rootPk"in t)))return t;throw Error("Invalid backup structure after JSON parse.")}catch(t){if(t instanceof SyntaxError)return{wif:s};throw t}}catch(t){if(d=t,t instanceof DOMException&&"OperationError"===t.name)continue;throw t}if(console.error("All decryption attempts failed. Last error:",d),d&&"OperationError"===d.name)throw Error("Decryption failed: Invalid passphrase or corrupted data across all attempted iteration counts.");throw d||Error("Decryption failed: Invalid passphrase or corrupted data across all attempted iteration counts.")}async function p(t,e,i){if(!(t&&"object"==typeof t&&("xprv"in t&&"string"==typeof t.xprv&&"ids"in t&&"string"==typeof t.ids&&"mnemonic"in t&&"string"==typeof t.mnemonic||"rootPk"in t&&"string"==typeof t.rootPk&&"ids"in t&&"string"==typeof t.ids&&!("xprv"in t)||"wif"in t&&"string"==typeof t.wif&&"id"in t&&"string"==typeof t.id||"wif"in t&&"string"==typeof t.wif&&!("id"in t)&&!("xprv"in t)&&!("rootPk"in t)||"ordPk"in t&&"string"==typeof t.ordPk&&"payPk"in t&&"string"==typeof t.payPk&&"identityPk"in t&&"string"==typeof t.identityPk||"encryptedVault"in t&&"string"==typeof t.encryptedVault||"payPk"in t&&"string"==typeof t.payPk&&"ordPk"in t&&"string"==typeof t.ordPk&&("mnemonic"in t||"payDerivationPath"in t||"ordDerivationPath"in t)||"chromeStorage"in t&&"object"==typeof t.chromeStorage&&"accountData"in t)))throw Error("Invalid payload: Payload must be an object matching BapMasterBackup, BapMemberBackup, WifBackup, OneSatBackup, VaultBackup, YoursWalletBackup, or YoursWalletZipBackup structure.");if("string"!=typeof e||0===e.length)throw Error("Invalid passphrase: Passphrase must be a non-empty string.");if(e.length<8)throw Error("Invalid passphrase: Passphrase must be at least 8 characters long.");return d(t,e,i)}async function y(t,e,i){if("string"!=typeof t||0===t.length)throw Error("Invalid encryptedString: Must be a non-empty string.");if("string"!=typeof e||0===e.length)throw Error("Invalid passphrase: Passphrase must be a non-empty string.");return u(t,e,i)}t.i(48647);var f=t.i(41030);t.i(46182),t.i(52255),t.i(2769),t.i(40648),t.i(99847),t.i(73374);var f=f,g=async(t,e,i,r)=>{let s=`${i}${t}`;return(await fetch(s,{method:"post",headers:{"Content-type":"application/json; charset=utf-8",token:r,format:"json"},body:JSON.stringify(e)})).json()},m=(t,e)=>async(i,r)=>g(i,r,t,e),{toHex:b,toArray:w}=o.Utils,A="1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT",v=b(w(A)),P="15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva",k=(b(w(P)),"https://api.sigmaidentity.com/v1"),x="m/424150'/0'/0'",K="m/424150'/2147483647'/2147483647'",E="1-bap-identity",$={getRandomBytes(t=32){if("u">typeof globalThis&&globalThis.crypto&&globalThis.crypto.getRandomValues){let e=new Uint8Array(t);return globalThis.crypto.getRandomValues(e),e}throw Error("Secure random number generation not available. crypto.getRandomValues() is required for cryptographic operations. This environment may not be suitable for secure key generation.")},getRandomString(t=32){return Array.from(this.getRandomBytes(t),t=>t.toString(16).padStart(2,"0")).join("")},getSigningPathFromHex(t,e=!0){let i="m",r=t.match(/.{1,8}/g);if(!r)throw Error("Invalid hex string");for(let t of r){let r=Number(`0x${t}`);r>0x7fffffff&&(r-=0x7fffffff),i+=`/${r}${e?"'":""}`}return i},getNextIdentityPath(t){let e=t.split("/"),i=e[e.length-2],r=!1;i.match("'")&&(r=!0);let s=(Number(i.replace(/[^0-9]/g,""))+1).toString();return e[e.length-2]=s+(r?"'":""),e[e.length-1]=`0${r?"'":""}`,e.join("/")},getNextPath(t){let e=t.split("/"),i=e[e.length-1],r=!1;i.match("'")&&(r=!0);let s=(Number(i.replace(/[^0-9]/g,""))+1).toString();return e[e.length-1]=s+(r?"'":""),e.join("/")}},{toArray:S,toUTF8:I,toBase64:O}=o.Utils,{magicHash:D}=a.BSM,{electrumDecrypt:B,electrumEncrypt:j}=a.ECIES;class _{identityAttributes={};signWithBSM(t,e){let i=e.toPublicKey().toAddress(),r=a.BSM.sign(t,e,"raw"),s=new o.BigNumber(D(t)),n=r.CalculateRecoveryFactor(e.toPublicKey(),s);return{address:i,signature:a.BSM.sign(t,e,"raw").toCompact(n,!0,"base64")}}encrypt(t,e){let{privKey:i,pubKey:r}=this.getEncryptionKey(),s=e?o.PublicKey.fromString(e):r;return O(j(S(t),s,i))}decrypt(t,e){let{privKey:i}=this.getEncryptionKey(),r;return e&&(r=o.PublicKey.fromString(e)),I(B(S(t,"base64"),i,r))}signOpReturnWithAIP(t,e){let i=this.getAIPMessageBuffer(t),{address:r,signature:s}=this.signMessage(i.flat(),e);return this.formatAIPOutput(i,r,s)}getAttributes(){return this.identityAttributes}getAttribute(t){return this.identityAttributes[t]?this.identityAttributes[t]:null}setAttribute(t,e){e&&(this.identityAttributes[t]?this.updateExistingAttribute(t,e):this.createNewAttribute(t,e))}unsetAttribute(t){delete this.identityAttributes[t]}addAttribute(t,e,i=""){let r=i;i||(r=$.getRandomString()),this.identityAttributes[t]={value:e,nonce:r}}getAttributeUrns(){let t="";for(let e in this.identityAttributes){let i=this.getAttributeUrn(e);i&&(t+=`${i}
`)}return t}getAttributeUrn(t){let e=this.identityAttributes[t];return e?`urn:bap:id:${t}:${e.value}:${e.nonce}`:null}parseStringUrns(t){let e={};for(let i of t.replace(/^\s+/g,"").replace(/\r/gm,"").split(`
`)){let t=i.replace(/^\s+/g,"").replace(/\s+$/g,"").split(":");"urn"===t[0]&&"bap"===t[1]&&"id"===t[2]&&t[3]&&t[4]&&t[5]&&(e[t[3]]={value:t[4],nonce:t[5]})}return e}parseAttributes(t){if("string"==typeof t)return this.parseStringUrns(t);for(let e in t)if(!t[e].value||!t[e].nonce)throw Error("Invalid identity attribute");return t||{}}updateExistingAttribute(t,e){if("string"==typeof e){this.identityAttributes[t].value=e;return}this.identityAttributes[t].value=e.value||"",e.nonce&&(this.identityAttributes[t].nonce=e.nonce)}createNewAttribute(t,e){"string"==typeof e?this.addAttribute(t,e):this.addAttribute(t,e.value||"",e.nonce)}getAIPMessageBuffer(t,e){let i=t.findIndex(t=>t[0]===f.default.OP_RETURN),r=[];if(-1===i&&(r.push([f.default.OP_RETURN]),i=0),e)for(let s of e)r.push(t[i+s]);else for(let e of t)r.push(e);return r}formatAIPOutput(t,e,i){return[...t,S("|"),S(P),S("BITCOIN_ECDSA"),S(e),S(i,"base64")]}}var{toArray:M,toUTF8:C,toBase64:N,toHex:T}=o.Utils,{electrumDecrypt:F,electrumEncrypt:W}=a.ECIES;class z extends _{key;idName;description;address;identityKey;constructor(t,e={}){super(),this.key=t,this.address=this.getIdentitySigningKey().toPublicKey().toAddress(),this.idName="Member ID 1",this.description="",this.identityKey="",this.identityAttributes=this.parseAttributes(e)}getIdentitySigningKey(){return this.key.deriveChild(this.key.toPublicKey(),E)}getMemberKey(){return this.key.toPublicKey().toString()}getLegacyAddress(){return this.key.toPublicKey().toAddress()}signMessage(t,e){let i=this.getIdentitySigningKey();return this.signWithBSM(t,i)}signOpReturnWithAIP(t){let e=this.getAIPMessageBuffer(t),{address:i,signature:r}=this.signMessage(e.flat());return this.formatAIPOutput(e,i,r)}getPublicKey(){return this.getIdentitySigningKey().toPublicKey().toString()}import(t){this.idName=t.name,this.description=t.description,this.key=o.PrivateKey.fromWif(t.derivedPrivateKey),this.address=this.getIdentitySigningKey().toPublicKey().toAddress(),this.identityAttributes=t.identityAttributes||{},this.identityKey=t.identityKey}static fromMemberIdentity(t){let e=new z(o.PrivateKey.fromWif(t.derivedPrivateKey));return e.import(t),e}static fromBackup(t){let e=new z(o.PrivateKey.fromWif(t.wif)),i=JSON.parse(e.decrypt(t.id));return e.import(i),e}export(){return{name:this.idName,description:this.description,derivedPrivateKey:this.key.toWif(),address:this.address,identityAttributes:this.getAttributes(),identityKey:this.identityKey}}getEncryptionKey(){return{privKey:this.key.deriveChild(this.key.toPublicKey(),K),pubKey:this.key.deriveChild(this.key.toPublicKey(),K).toPublicKey()}}getEncryptionPublicKey(){let{pubKey:t}=this.getEncryptionKey();return t.toString()}getEncryptionPrivateKeyWithSeed(t){let e=T(o.Hash.sha256(t,"utf8"));return this.key.deriveChild(this.key.toPublicKey(),e)}getEncryptionKeyWithSeed(t){let e=this.getEncryptionPrivateKeyWithSeed(t);return{privKey:e,pubKey:e.toPublicKey()}}getEncryptionPublicKeyWithSeed(t){return this.getEncryptionPrivateKeyWithSeed(t).toPublicKey().toString()}encryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s=r.toPublicKey(),n=this.key.toPublicKey().constructor,a=i?n.fromString(i):s;return N(W(M(t),a,r))}decryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s;return i&&(s=o.PublicKey.fromString(i)),C(F(M(t,"base64"),r,s))}exportForBackup(t){let e=this.export(),i=this.encrypt(JSON.stringify(e));return{wif:this.key.toWif(),id:i,...t&&{label:t},createdAt:new Date().toISOString()}}}var{toArray:R,toHex:q,toBase58:H,toUTF8:U,toBase64:J}=o.Utils,{electrumDecrypt:V,electrumEncrypt:L}=a.ECIES;class Q extends _{#t;#e;#i;#r=k;#s="";#n;#a;#o;#h;idName;description;rootAddress;identityKey;identityAttributes;getApiData;constructor(t,e={},i=""){if(super(),t instanceof a.HD)if(this.#i=!1,i){let e=q(o.Hash.sha256(i,"utf8")),r=$.getSigningPathFromHex(e);this.#t=t.derive(r)}else this.#t=t;else if(this.#i=!0,this.#e=t.rootPk,i){let t=q(o.Hash.sha256(i,"utf8"));this.#e=this.#e.deriveChild(this.#e.toPublicKey(),t)}if(this.#h=i,this.idName="ID 1",this.description="",this.#n=`${x}/0/0/0`,this.#a=`${x}/0/0/0`,this.#o=`${x}/0/0/1`,this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n);this.rootAddress=t.toPublicKey().toAddress()}else{if(!this.#t)throw Error("HD private key not initialized");let t=this.#t.derive(this.#n);this.rootAddress=t.privKey.toPublicKey().toAddress()}this.identityKey=this.deriveIdentityKey(this.rootAddress);let r={...e};this.identityAttributes=this.parseAttributes(r),this.getApiData=m(this.#r,this.#s)}set BAP_SERVER(t){this.#r=t}get BAP_SERVER(){return this.#r}set BAP_TOKEN(t){this.#s=t}get BAP_TOKEN(){return this.#s}deriveIdentityKey(t){let e=q(o.Hash.sha256(t,"utf8"));return H(o.Hash.ripemd160(e,"hex"))}parseAttributes(t){if("string"==typeof t)return this.parseStringUrns(t);for(let e in t)if(!t[e].value||!t[e].nonce)throw Error("Invalid identity attribute");return t||{}}parseStringUrns(t){let e={};for(let i of t.replace(/^\s+/g,"").replace(/\r/gm,"").split(`
`)){let t=i.replace(/^\s+/g,"").replace(/\s+$/g,"").split(":");"urn"===t[0]&&"bap"===t[1]&&"id"===t[2]&&t[3]&&t[4]&&t[5]&&(e[t[3]]={value:t[4],nonce:t[5]})}return e}getIdentityKey(){return this.identityKey}set rootPath(t){if(this.#i){if(this.#n=t,!this.#e)throw Error("Master private key not initialized");let e=this.#e.deriveChild(this.#e.toPublicKey(),t);this.rootAddress=e.toPublicKey().toAddress(),this.#a=t,this.#o=t}else{let e=t;if(t.split("/").length<5&&(e=`${x}${t}`),!this.validatePath(e))throw Error(`invalid signing path given ${e}`);if(this.#n=e,!this.#t)throw Error("HD private key not initialized");let i=this.#t.derive(e);this.rootAddress=i.pubKey.toAddress(),this.#a=e,this.#o=e}this.identityKey=this.deriveIdentityKey(this.rootAddress)}get rootPath(){return this.#n}getRootPath(){return this.#n}set currentPath(t){if(this.#i)this.#a=this.#o,this.#o=t;else{let e=t;if(t.split("/").length<5&&(e=`${x}${t}`),!this.validatePath(e))throw Error("invalid signing path given");this.#a=this.#o,this.#o=e}}get currentPath(){return this.#o}get previousPath(){return this.#a}get idSeed(){return this.#h}incrementPath(){this.currentPath=$.getNextPath(this.currentPath)}validatePath(t){if(t.match(/\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?/)){let e=t.split("/");if(7===e.length&&0x7fffffff>=Number(e[1].replace("'",""))&&0x7fffffff>=Number(e[2].replace("'",""))&&0x7fffffff>=Number(e[3].replace("'",""))&&0x7fffffff>=Number(e[4].replace("'",""))&&0x7fffffff>=Number(e[5].replace("'",""))&&0x7fffffff>=Number(e[6].replace("'","")))return!0}return!1}getInitialIdTransaction(){return this.getIdTransaction(this.#n)}getIdTransaction(t=""){if(this.#o===this.#n)throw Error("Current path equals rootPath. ID was probably not initialized properly");let e=[R(A),R("ID"),R(this.identityKey),R(this.getCurrentAddress())];return this.signOpReturnWithAIP(e,t||this.#a)}getPathDerivedKey(t){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");return this.#e.deriveChild(this.#e.toPublicKey(),t)}if(!this.#t)throw Error("HD private key not initialized");return this.#t.derive(t).privKey}getIdentitySigningKeyForPath(t){let e=this.getPathDerivedKey(t);return e.deriveChild(e.toPublicKey(),E)}getMemberKey(t){let e=t||this.#o;return this.getPathDerivedKey(e).toPublicKey().toString()}getLegacyAddress(t){let e=t||this.#o;return this.getPathDerivedKey(e).toPublicKey().toAddress()}needsRotation(t){return(t||this.rootAddress)===this.getLegacyAddress(this.#n)}getLegacyRotationTransaction(){let t=this.getAddress(this.#n),e=[R(A),R("ID"),R(this.identityKey),R(t)],i=this.getAIPMessageBuffer(e),r=this.getPathDerivedKey(this.#n),{address:s,signature:n}=this.signWithBSM(i.flat(),r);return this.formatAIPOutput(e,s,n)}getAddress(t){return this.getIdentitySigningKeyForPath(t).toPublicKey().toAddress()}getCurrentAddress(){return this.getAddress(this.#o)}getEncryptionKey(){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n),e=t.deriveChild(t.toPublicKey(),K);return{privKey:e,pubKey:e.toPublicKey()}}if(!this.#t)throw Error("HD private key not initialized");let t=this.#t.derive(this.#n).derive(K).privKey;return{privKey:t,pubKey:t.toPublicKey()}}getEncryptionKeyType42(){if(this.#i)return this.getEncryptionKey();if(!this.#t)throw Error("HD private key not initialized");let t=this.#t.derive(this.#n),e=t.privKey.deriveChild(t.toPublic().pubKey,K);return{privKey:e,pubKey:e.toPublicKey()}}getEncryptionPublicKey(){let{pubKey:t}=this.getEncryptionKey();return t.toString()}getEncryptionPublicKeyWithSeed(t){return this.getEncryptionPrivateKeyWithSeed(t).toPublicKey().toString()}encrypt(t,e){let{privKey:i,pubKey:r}=this.getEncryptionKey(),s=e?o.PublicKey.fromString(e):r;return J(L(R(t),s,i))}decrypt(t,e){let{privKey:i}=this.getEncryptionKey(),r;return e&&(r=o.PublicKey.fromString(e)),U(V(R(t,"base64"),i,r))}encryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s=r.toPublicKey(),n=i?o.PublicKey.fromString(i):s;return J(L(R(t),n,r))}decryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s;return i&&(s=o.PublicKey.fromString(i)),U(V(R(t,"base64"),r,s))}getEncryptionPrivateKeyWithSeed(t){let e=q(o.Hash.sha256(t,"utf8"));if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n);return t.deriveChild(t.toPublicKey(),e)}if(!this.#t)throw Error("HD private key not initialized");let i=$.getSigningPathFromHex(e);return this.#t.derive(this.#n).derive(i).privKey}getAttestation(t){let e=o.Hash.sha256(t,"utf8");return`bap:attest:${q(e)}:${this.getIdentityKey()}`}getAttestationHash(t){let e=this.getAttributeUrn(t);if(!e)return null;let i=this.getAttestation(e);return q(o.Hash.sha256(i,"utf8"))}signMessage(t,e){let i=e||this.#o,r=this.getIdentitySigningKeyForPath(i);return this.signWithBSM(t,r)}signMessageWithSeed(t,e){let i=q(o.Hash.sha256(e,"utf8")),r;if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n);r=t.deriveChild(t.toPublicKey(),i)}else{if(!this.#t)throw Error("HD private key not initialized");let t=$.getSigningPathFromHex(i);r=this.#t.derive(this.#n).derive(t).privKey}let s=r.deriveChild(r.toPublicKey(),E);return this.signWithBSM(R(t,"utf8"),s)}signOpReturnWithAIP(t,e=""){let i=this.getAIPMessageBuffer(t),{address:r,signature:s}=this.signMessage(i.flat(),e);return this.formatAIPOutput(t,r,s)}async getIdSigningKeys(){let t=await this.getApiData("/signing-keys",{idKey:this.identityKey});return console.log("getIdSigningKeys",t),t}async getAttributeAttestations(t){let e=this.getAttestationHash(t),i=await this.getApiData("/attestation/get",{hash:e});return console.log("getAttestations",t,e,i),i}import(t){this.idName=t.name,this.description=t.description||"",this.identityKey=t.identityKey,this.#n=t.rootPath,this.rootAddress=t.rootAddress,this.#a=t.previousPath,this.#o=t.currentPath,this.#h=("idSeed"in t?t.idSeed:"")||"",this.identityAttributes=this.parseAttributes(t.identityAttributes)}export(){return{name:this.idName,description:this.description,identityKey:this.identityKey,rootPath:this.#n,rootAddress:this.rootAddress,previousPath:this.#a,currentPath:this.#o,idSeed:this.#h,identityAttributes:this.getAttributes(),lastIdPath:""}}exportMemberBackup(){let t=this.getPathDerivedKey(this.#o),e=this.getIdentitySigningKeyForPath(this.#o);return{name:this.idName,description:this.description,derivedPrivateKey:t.toWif(),address:e.toPublicKey().toAddress(),identityAttributes:this.getAttributes(),identityKey:this.identityKey}}newId(){return this.incrementPath(),new z(this.getPathDerivedKey(this.#o))}exportMember(){let t=this.exportMemberBackup(),e=this.getPathDerivedKey(this.#o),i=J(L(R(JSON.stringify(t)),e.toPublicKey()));return{wif:t.derivedPrivateKey,encryptedData:i}}}var{toArray:Z,toUTF8:G,toBase64:Y,toHex:X}=o.Utils,{electrumEncrypt:tt,electrumDecrypt:te}=a.ECIES;class ti{#t;#e;#i;#r={};#s=k;#n="";#a="";#o=0;getApiData;constructor(t,e="",i=""){if(!t)throw Error("No key source given");"string"==typeof t?(this.#t=a.HD.fromString(t),this.#i=!1):(this.#e=o.PrivateKey.fromWif(t.rootPk),this.#i=!0),e&&(this.#n=e),i&&(this.#s=i),this.getApiData=m(this.#s,this.#n)}get lastIdPath(){return this.#a}getPublicKey(t=""){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");return t?this.#e.deriveChild(this.#e.toPublicKey(),t).toPublicKey().toString():this.#e.toPublicKey().toString()}if(!this.#t)throw Error("HD private key not initialized");return t?this.#t.derive(t).pubKey.toString():this.#t.pubKey.toString()}getHdPublicKey(t=""){if(this.#i)throw Error("HD public keys are not available in Type 42 mode");if(!this.#t)throw Error("HD private key not initialized");return t?this.#t.derive(t).toPublic().toString():this.#t.toPublic().toString()}set BAP_SERVER(t){for(let e in this.#s=t,this.#r)this.#r[e].BAP_SERVER=t}get BAP_SERVER(){return this.#s}set BAP_TOKEN(t){for(let e in this.#n=t,this.#r)this.#r[e].BAP_TOKEN=t}get BAP_TOKEN(){return this.#n}checkIdBelongs(t){let e;if(this.#i){if(!this.#e)throw Error("Master private key not initialized");e=this.#e.deriveChild(this.#e.toPublicKey(),t.rootPath).toPublicKey().toAddress()}else{if(!this.#t)throw Error("HD private key not initialized");e=this.#t.derive(t.rootPath).pubKey.toAddress()}if(e!==t.rootAddress)throw Error("ID does not belong to this private key");return!0}listIds(){return Object.keys(this.#r)}newId(t,e,i={},r=""){let s,n,a,o,h;if("object"==typeof t||void 0===t||"string"==typeof t&&t.startsWith("/")?(n="string"==typeof t?t:void 0,a="object"==typeof t?t:"object"==typeof e?e:{},s="Default Identity"):(s=t,n="string"==typeof e?e:void 0,a="object"==typeof e?e:i),n?o=n:this.#i?(o=`bap:${this.#o}`,this.#o++):o=this.getNextValidPath(),this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");h=new Q({rootPk:this.#e},a,r)}else{if(!this.#t)throw Error("HD private key not initialized");h=new Q(this.#t,a,r)}(h.BAP_SERVER=this.#s,h.BAP_TOKEN=this.#n,h.idName=s,h.rootPath=o,this.#i)?h.currentPath=o:h.currentPath=$.getNextPath(o);let l=h.getIdentityKey();return this.#r[l]=h,this.#a=o,this.#r[l]}removeId(t){delete this.#r[t]}getNextValidPath(){return this.#a?$.getNextIdentityPath(this.#a):`/0'/${Object.keys(this.#r).length}'/0'`}newIdWithCounter(t,e=`Identity ${t}`){if(!this.#i)throw Error("newIdWithCounter only works in Type 42 mode");let i=`bap:${t}`;return this.newId(e,i)}getId(t){return this.#r[t]||null}setId(t){this.checkIdBelongs(t),this.#r[t.getIdentityKey()]=t}importIds(t,e=!0){if(e&&"string"==typeof t)return void this.importEncryptedIds(t);if(!t.lastIdPath)throw Error("ID cannot be imported as it is not complete");if(!t.ids)throw Error(`ID data is not in the correct format: ${t}`);let i=t.lastIdPath;for(let e of t.ids){let t;if(!e.identityKey||!e.identityAttributes||!e.rootAddress)throw Error("ID cannot be imported as it is not complete");if(this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");t=new Q({rootPk:this.#e},{},e.idSeed)}else{if(!this.#t)throw Error("HD private key not initialized");t=new Q(this.#t,{},e.idSeed)}if(t.BAP_SERVER=this.#s,t.BAP_TOKEN=this.#n,t.import(e),""===i&&(i=t.currentPath),this.checkIdBelongs(t),this.#r[t.getIdentityKey()]=t,this.#i&&t.rootPath.startsWith("bap:")){let e=t.rootPath.split(":");if(e.length>=2){let t=Number.parseInt(e[1],10);Number.isNaN(t)||(this.#o=Math.max(this.#o,t+1))}}}this.#a=i}importEncryptedIds(t){let e=JSON.parse(this.decrypt(t));if(Array.isArray(e)){console.log(`Importing old format:
`,e),this.importOldIds(e);return}if("object"!=typeof e)throw Error("decrypted, but found unrecognized identities format");this.importIds(e,!1)}importOldIds(t){for(let e of t){let t;if(this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");t=new Q({rootPk:this.#e},{},e.idSeed??"")}else{if(!this.#t)throw Error("HD private key not initialized");t=new Q(this.#t,{},e.idSeed??"")}t.BAP_SERVER=this.#s,t.BAP_TOKEN=this.#n,t.import(e),this.checkIdBelongs(t),this.#r[t.getIdentityKey()]=t,this.#a=t.currentPath}}exportIds(t,e=!0){let i={lastIdPath:this.#a,ids:[]};for(let e of t||Object.keys(this.#r)){if(!this.#r[e])throw Error(`Identity ${e} not found`);i.ids.push(this.#r[e].export())}return e?this.encrypt(JSON.stringify(i)):i}exportId(t,e=!0){let i={lastIdPath:this.#a,ids:[]};return(i.ids.push(this.#r[t].export()),e)?this.encrypt(JSON.stringify(i)):i}encrypt(t){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let e=this.#e.deriveChild(this.#e.toPublicKey(),K);return Y(tt(Z(t),e.toPublicKey(),null))}if(!this.#t)throw Error("HD private key not initialized");let e=this.#t.derive(K);return Y(tt(Z(t),e.pubKey,null))}decrypt(t){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let e=this.#e.deriveChild(this.#e.toPublicKey(),K);return G(te(Z(t,"base64"),e))}if(!this.#t)throw Error("HD private key not initialized");let e=this.#t.derive(K);return G(te(Z(t,"base64"),e.privKey))}signAttestationWithAIP(t,e,i=0,r=""){let s=this.getId(e);if(!s)throw Error("Could not find identity to attest with");let n=this.getAttestationBuffer(t,i,r),{address:a,signature:o}=s.signMessage(n);return this.createAttestationTransaction(t,i,a,o,r)}verifyAttestationWithAIP(t){if(!t.every(t=>Array.isArray(t))||t[0][0]!==f.default.OP_RETURN||X(t[1])!==v)throw Error("Not a valid BAP transaction");let e=5*("44415441"===X(t[7])),i={type:G(t[2]),hash:X(t[3]),sequence:G(t[4]),signingProtocol:G(t[7+e]),signingAddress:G(t[8+e]),signature:Y(t[9+e])};e&&t[3]===t[8]&&(i.data=X(t[9])),console.log({attestation:i});try{let r=[];for(let i=0;i<6+e;i++)r.push(t[i]);i.verified=this.verifySignature(r.flat(),i.signingAddress,i.signature)}catch{i.verified=!1}return i}createAttestationTransaction(t,e,i,r,s=""){let n=[[f.default.OP_RETURN],Z(A),Z("ATTEST"),Z(t),Z(`${e}`),Z("|")];return s&&n.push(Z(A),Z("DATA"),Z(t),Z(s),Z("|")),n.push(Z(P),Z("BITCOIN_ECDSA"),Z(i),Z(r,"base64")),console.log({elements:n}),n}getAttestationBuffer(t,e=0,i=""){let r=[[f.default.OP_RETURN],Z(A),Z("ATTEST"),Z(t),Z(`${e}`),Z("|")];return i&&r.push(Z(A),Z("DATA"),Z(t),Z(i),Z("|")),r.flat()}verifySignature(t,e,i){let r;r=Array.isArray(t)?t:Buffer.isBuffer(t)?[...t]:Z(t,"utf8");let s=o.Signature.fromCompact(i,"base64"),n;for(let t=0;t<4;t++)try{if(n=s.RecoverPublicKey(t,new o.BigNumber(a.BSM.magicHash(r))),a.BSM.verify(r,s,n)&&n.toAddress()===e)return!0}catch{}return!1}async verifyChallengeSignature(t,e,i,r){if(!this.verifySignature(i,e,r))return!1;try{let s=await this.getApiData("/attestation/valid",{idKey:t,address:e,challenge:i,signature:r});if(s?.status==="success"&&s?.result?.valid===!0)return!0;return!1}catch(t){return console.error("API call failed:",t),!1}}async isValidAttestationTransaction(t){return!!this.verifyAttestationWithAIP(t)&&this.getApiData("/attestation/valid",{tx:t})}async getIdentityFromAddress(t){return this.getApiData("/identity/from-address",{address:t})}async getIdentity(t){return this.getApiData("/identity/get",{idKey:t})}async getAttestationsForHash(t){return this.getApiData("/attestations",{hash:t})}exportForBackup(t,e,i){let r={ids:this.exportIds(),...t&&{label:t},createdAt:new Date().toISOString()};if(this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");return{...r,rootPk:this.#e.toWif()}}if(!this.#t)throw Error("HD private key not initialized");return{...r,xprv:e||this.#t.toString(),mnemonic:i||""}}exportMemberForBackup(t,e){let i=this.#r[t];if(!i)throw Error(`Identity ${t} not found`);let r=i.exportMember();return{wif:r.wif,id:r.encryptedData,...e&&{label:e},createdAt:new Date().toISOString()}}}var tr=t.i(52738);let{toArray:ts,toHex:tn}=o.Utils,ta=(0,i.join)((0,e.homedir)(),".tokenpass"),to=class{wallet;bap=null;currentMnemonic=null;cachedPasswordHash=null;cachedRootPkWif=null;basePath;configFile;defaultBackupFile;currentBackupPath;constructor(t){this.wallet=t.wallet,this.basePath=t.basePath??ta,this.configFile=(0,i.join)(this.basePath,"config.json"),this.defaultBackupFile=(0,i.join)(this.basePath,"backup.bep"),this.currentBackupPath=this.defaultBackupFile,this.ensureDir(),this.loadConfig()}ensureDir(){(0,n.existsSync)(this.basePath)||(0,n.mkdirSync)(this.basePath,{recursive:!0})}loadConfig(){if((0,n.existsSync)(this.configFile))try{let t=JSON.parse((0,n.readFileSync)(this.configFile,"utf8"));this.currentBackupPath=t.currentBackupPath||this.defaultBackupFile}catch{this.currentBackupPath=this.defaultBackupFile}}saveConfig(t){this.ensureDir(),(0,n.writeFileSync)(this.configFile,JSON.stringify(t,null,2))}getConfig(){if((0,n.existsSync)(this.configFile))try{return JSON.parse((0,n.readFileSync)(this.configFile,"utf8"))}catch{}return{currentBackupPath:this.defaultBackupFile,knownBackups:[{path:this.defaultBackupFile,label:"Default",addedAt:new Date().toISOString()}]}}listBackups(){return this.getConfig().knownBackups.map(t=>({path:t.path,label:t.label,exists:(0,n.existsSync)(t.path),isCurrent:t.path===this.currentBackupPath}))}discoverBackups(){let t=this.listBackups(),e=new Set(t.map(t=>t.path)),r=[];try{r=(0,n.readdirSync)(this.basePath).filter(t=>t.endsWith(".bep")).map(t=>(0,i.join)(this.basePath,t)).filter(t=>!e.has(t)).map(t=>({path:t,label:(0,i.basename)(t),exists:!0,isCurrent:!1,isDiscovered:!0}))}catch{}return[...t,...r]}addBackup(t,e){let r=this.getConfig(),s=r.knownBackups.find(e=>e.path===t);return s?e&&(s.label=e):r.knownBackups.push({path:t,label:e||(0,i.basename)(t),addedAt:new Date().toISOString()}),this.saveConfig(r),{path:t,label:e||(0,i.basename)(t),exists:(0,n.existsSync)(t),isCurrent:t===this.currentBackupPath}}removeBackup(t){let e=this.getConfig(),i=e.knownBackups.findIndex(e=>e.path===t);if(-1===i)return!1;if(t===this.currentBackupPath)throw Error("Cannot remove the currently active backup");return e.knownBackups.splice(i,1),this.saveConfig(e),!0}switchBackup(t){let e=this.getConfig();if(!e.knownBackups.find(e=>e.path===t))throw Error("Backup not in known list - add it first");this.clearBap(),this.currentBackupPath=t,e.currentBackupPath=t,this.saveConfig(e)}async createBackupAt(t,e,i,r){this.clearBap(),this.currentBackupPath=t;let s=await this.create(e,r);this.addBackup(t,i);let n=this.getConfig();return n.currentBackupPath=t,this.saveConfig(n),s}async importFromContent(t,e){let i,r,s,n;try{let e=JSON.parse(t);if("xprv"in e||"rootPk"in e)i=e;else throw Error("Invalid backup format")}catch{try{i=await y(t,e)}catch(t){throw Error(`Failed to read backup: not valid JSON and decryption failed - ${t}`)}}if("rootPk"in i&&i.rootPk){let t=i;if(r=t.rootPk,s=t.mnemonic){let t=new tr.MnemonicEN(s);t.setPassphrase(e),n=a.HD.fromSeed(t.toBytes())}else{let t=o.PrivateKey.fromWif(r);n=a.HD.fromSeed(ts(t.toHex(),"hex"))}}else if("xprv"in i){let t=i;r=(n=a.HD.fromString(t.xprv)).privKey.toWif(),s=t.mnemonic,this.bap=new ti(t.xprv),i.ids&&this.bap.importIds(i.ids)}else throw Error("Invalid backup format - missing rootPk or xprv");if("rootPk"in i&&i.rootPk&&!this.bap&&(this.bap=new ti({rootPk:r}),i.ids&&this.bap.importIds(i.ids)),!this.bap)throw Error("Failed to initialize BAP");return 0===this.bap.listIds().length&&this.bap.newIdWithCounter(0,"Primary Identity"),this.cachedPasswordHash=e,this.cachedRootPkWif=r,this.currentMnemonic=s||null,await this.saveBackup(r,s||"",e),{seedData:{hex:"",key:n,mnemonic:s},identityCount:this.bap.listIds().length}}getCurrentBackupPath(){return this.currentBackupPath}isUnlocked(){return null!==this.bap&&null!==this.cachedPasswordHash}exists(){return(0,n.existsSync)(this.currentBackupPath)}getBap(){return this.bap}getBapId(){return this.bap?this.bap.listIds()[0]??null:null}getIdentities(){return this.bap?this.bap.listIds().map((t,e)=>{let i=this.bap.getId(t);return i?{idKey:t,name:i.idName||"Unnamed Identity",rootAddress:i.rootAddress,counter:e}:null}).filter(t=>null!==t):null}getIdentityInfo(t){if(!this.bap)return null;let e=this.bap.getId(t);if(!e)return null;let i=this.bap.listIds().indexOf(t);return{idKey:t,name:e.idName||"Unnamed Identity",description:e.description||"",rootAddress:e.rootAddress,identityKey:e.identityKey,counter:i>=0?i:0,attributes:e.getAttributes()}}async createIdentity(t){if(!this.isUnlocked())throw Error("Wallet not unlocked");let e=this.bap.listIds().length,i=this.bap.newIdWithCounter(e,t).getIdentityKey();return await this.save(),i}async get(t){if(!this.exists())return null;try{let e,i,r,s,h=(0,n.readFileSync)(this.currentBackupPath,"utf8"),l=await y(h,t);if(!("xprv"in l)&&!("rootPk"in l))return console.error("Invalid backup format - expected BapMasterBackup"),null;if("rootPk"in l&&l.rootPk)if(e=l.rootPk,i=l.mnemonic){let e=new tr.MnemonicEN(i);e.setPassphrase(t),r=a.HD.fromSeed(e.toBytes())}else{let t=o.PrivateKey.fromWif(e);r=a.HD.fromSeed(ts(t.toHex(),"hex"))}else if("xprv"in l)e=(r=a.HD.fromString(l.xprv)).privKey.toWif(),i=l.mnemonic,this.bap=new ti(l.xprv),l.ids&&this.bap.importIds(l.ids);else throw Error("Invalid backup format - missing rootPk or xprv");if("rootPk"in l&&l.rootPk&&!this.bap&&(this.bap=new ti({rootPk:e}),l.ids&&this.bap.importIds(l.ids)),this.cachedPasswordHash=t,this.cachedRootPkWif=e,this.currentMnemonic=i||null,i){let e=new tr.MnemonicEN(i);e.setPassphrase(t);let n=e.toBytes();s={hex:tn(n),key:r,mnemonic:i}}else s={hex:"",key:r,mnemonic:void 0};return s}catch(t){return console.error("Failed to decrypt backup:",t),null}}async create(e,i){let r;if(i)r=new tr.MnemonicEN(i);else{let{generateMnemonic:e}=await t.A(68472);r=e(128)}r.setPassphrase(e);let s=r.toBytes(),n=tn(s),o=a.HD.fromSeed(s),h=o.privKey.toWif();return this.bap=new ti({rootPk:h}),this.bap.newIdWithCounter(0,"Primary Identity"),this.cachedPasswordHash=e,this.cachedRootPkWif=h,this.currentMnemonic=r.phrase,await this.saveBackup(h,r.phrase,e),{hex:n,key:o,mnemonic:r.phrase}}async importFromHex(t,e,i){let r=ts(t,"hex"),s=a.HD.fromSeed(r).privKey.toWif();return this.bap=new ti({rootPk:s}),this.bap.newIdWithCounter(0,"Primary Identity"),this.currentMnemonic=i||null,this.cachedRootPkWif=s,this.cachedPasswordHash=e,await this.saveBackup(s,i||"",e),this.wallet.seed(t,void 0,i)}async save(){if(!this.isUnlocked()||!this.cachedRootPkWif||!this.cachedPasswordHash)throw Error("Wallet not unlocked - call get() first");await this.saveBackup(this.cachedRootPkWif,this.currentMnemonic||"",this.cachedPasswordHash)}async saveBackup(t,e,i){if(!this.bap)throw Error("No BAP instance");let r={ids:this.bap.exportIds(),rootPk:t,mnemonic:e||void 0,label:"TokenPass",createdAt:new Date().toISOString()},s=await p(r,i);(0,n.writeFileSync)(this.currentBackupPath,s)}async exportKey(t){let e=await this.get(t);if(!e)throw Error("Failed to decrypt seed");return{hex:e.hex,mnemonic:e.mnemonic}}exportEncryptedBackup(){return this.exists()?(0,n.readFileSync)(this.currentBackupPath,"utf8"):null}async importEncryptedBackup(t,e){let i=await y(t,e);if(!("xprv"in i)&&!("rootPk"in i))throw Error("Invalid backup format - expected BapMasterBackup");(0,n.writeFileSync)(this.currentBackupPath,t);let r=await this.get(e);if(!r)throw Error("Failed to load imported backup");return r}async count(){return+!!this.exists()}clearBap(){this.bap=null,this.currentMnemonic=null,this.cachedPasswordHash=null,this.cachedRootPkWif=null}};var th=t.i(70231);let tl=globalThis;function tc(){return tl._sessionPrivateKey||(tl._sessionPrivateKey=o.PrivateKey.fromRandom(),tl._sessionPublicKey=tl._sessionPrivateKey.toPublicKey()),{privateKey:tl._sessionPrivateKey,publicKey:tl._sessionPublicKey}}t.s(["Session",0,{getPublicKey:()=>tc().publicKey.toString(),decryptBody:t=>{try{let e=o.Utils.toArray(t.ciphertext,"hex"),i=th.EncryptedMessage.decrypt(e,tc().privateKey),r=o.Utils.toUTF8(i);return JSON.parse(r)}catch{let t=Error("Failed to decrypt request body");throw t.code="SESSION_DECRYPT_FAILED",t}}}],95807);let td=class{db;state=null;constructor(t){const e=t.db;this.db=new t.Datastore({filename:`${e}/state.db`,autoload:!0})}setState(t){this.state=t}getState(){return this.state}async findOrCreate(t){let e=await this.findOne({host:t.host});return e||(e=await this.insert(t)),e}findOne(t){return new Promise(e=>{this.db.findOne(t,(t,i)=>{if(i){let{_id:t,...r}=i;e(r)}else e(null)})})}find(t){return new Promise(e=>{this.db.find(t,(t,i)=>{e(i)})})}delete(t){return new Promise(e=>{this.db.remove(t,(t,i)=>{e(i)})})}count(t){return new Promise(e=>{this.db.count(t,(t,i)=>{e(i)})})}insert(t){return new Promise(e=>{this.db.insert(t,(i,r)=>{this.setState(t),e(t)})})}update(t){return new Promise(e=>{this.db.update({host:t.host},{$set:t},{upsert:!0,returnUpdatedDocs:!0},(t,i,r)=>{t&&console.error("State update failed:",t.message),this.setState(r),e(r)})})}all(){return new Promise(t=>{this.db.find({},(e,i)=>{t(i)})})}};var{toBase64:tu,toArray:tp,toHex:ty}=o.Utils,tf=t=>{let e={...t,scheme:t.scheme??"brc77",bodyEncoding:t.bodyEncoding??"utf8"};return"bsm"===e.scheme?(t=>{let{privateKeyWif:e,requestPath:i,body:r}=t,s=t.bodyEncoding??"utf8",n=o.PrivateKey.fromWif(e),h=n.toPublicKey().toString(),l=t.timestamp??new Date().toISOString(),c=r?ty(o.Hash.sha256(tp(r,s))):"",d=`${i}|${l}|${c}`,u=a.BSM.sign(tp(d),n);return`${h}|bsm|${l}|${i}|${u}`})(e):(t=>{let{privateKeyWif:e,requestPath:i,body:r}=t,s=t.bodyEncoding??"utf8",n=o.PrivateKey.fromWif(e),a=n.toPublicKey().toString(),h=t.timestamp??new Date().toISOString(),l=r?ty(o.Hash.sha256(tp(r,s))):"",c=tp(`${i}|${h}|${l}`),d=tu(th.SignedMessage.sign(c,n));return`${a}|brc77|${h}|${i}|${d}`})(e)},tg=t=>{let e=t.split("|");if(5!==e.length)return null;let[i,r,s,n,a]=e;return"bsm"!==r&&"brc77"!==r?null:{pubkey:i,scheme:r,timestamp:s,requestPath:n,signature:a}},tm=(t,e,i=5,r="utf8")=>{let s=tg(t);return!!s&&!!((t,e,i=5)=>{let r=new Date(t.timestamp),s=new Date(e.timestamp);if(s.setMinutes(s.getMinutes()+i),r>s||t.requestPath!==e.requestPath)return!1;try{if(!o.PublicKey.fromString(t.pubkey))return!1}catch(t){return!1}return!0})(s,e,i)&&("bsm"===s.scheme?((t,e,i="utf8")=>{let{pubkey:r,timestamp:s,requestPath:n,signature:h}=t,l=e.body?ty(o.Hash.sha256(tp(e.body,i))):"",c=`${n}|${s}|${l}`,d=o.Signature.fromCompact(h,"base64"),u=o.PublicKey.fromString(r);return a.BSM.verify(tp(c),d,u)})(s,e,r):tb(s,e,r))},tb=(t,e,i="utf8")=>{let{timestamp:r,requestPath:s,signature:n}=t,a=e.body?ty(o.Hash.sha256(tp(e.body,i))):"",h=tp(`${s}|${r}|${a}`);return th.SignedMessage.verify(h,tp(n,"base64"))};let{toArray:tw,toHex:tA,toUTF8:tv}=o.Utils,tP=(t,e,i)=>{if(!e.priv)throw Error("Private key is required to sign");let r=o.PrivateKey.fromWif(e.priv),s=i?tw(t,i):tw(t,"utf8"),n=a.BSM.sign(s,r);return{address:e.address,message:t,sig:n,ts:Date.now()}},tk=(t,e)=>{if(!e.priv)throw Error("Private key is required to encrypt");let i=o.PrivateKey.fromWif(e.priv).toPublicKey(),r=tw(t,"utf8"),s=a.ECIES.electrumEncrypt(r,i);return{address:e.address,data:tA(s),ts:Date.now()}},tx=(t,e)=>{if(!e.priv)throw Error("Private key is required to decrypt");let i=o.PrivateKey.fromWif(e.priv),r=tw(t,"hex");return tv(a.ECIES.electrumDecrypt(r,i))},tK=t=>t.key.privKey,tE=async(t,e)=>{let i=`2-tokenpass-${e}`,r=tK(t),s=r.deriveChild(r.toPublicKey(),i);return{path:i,pub:s.toPublicKey().toString(),address:s.toPublicKey().toAddress(),host:e}},t$=(t,e)=>{let i=tK(t),r=i.deriveChild(i.toPublicKey(),e);return{privateKey:r,publicKey:r.toPublicKey()}},tS=(t,e,i)=>{let r,s;if(t)r=tw(t,"hex"),s=i;else{if(!e)throw Error("passphrase required creating initial seed");let t=(0,tr.generateMnemonic)(128);t.setPassphrase(e),r=t.toBytes(),s=t.phrase}let n=a.HD.fromSeed(r);return{hex:tA(r),key:n,mnemonic:s}},tI=(t,e,i,r)=>{let s=r?tw(t,r):tw(t,"utf8");try{let t=tw(i,"base64"),r=t[0],n=o.Signature.fromCompact(t),h=a.BSM.magicHash(s),l=new o.BigNumber(h);return n.RecoverPublicKey(r>=31?r-31:r-27,l).toAddress()===e}catch{return!1}},tO=(t,e,i,r="brc77")=>{if(!t.priv)throw Error("Private key is required to create auth token");return tf({privateKeyWif:t.priv,requestPath:e,body:i,scheme:r})},tD=(t,e,i,r=300)=>tm(t,{requestPath:e,timestamp:"",body:i},r),tB=t=>tg(t),tj=(t,e)=>{let i=`2-tokenpass-${e}`,r=t.deriveChild(t.toPublicKey(),i);return{privateKey:r,address:r.toPublicKey().toAddress(),invoiceNumber:i}},t_=(t,e,i)=>{let r=o.PublicKey.fromString(e),s=tA(o.Hash.sha256(tw(i,"utf8"))),n=`2-encrypt-${s}`;return{privateKey:t.deriveChild(r,n),invoiceNumber:n}},tM=(t,e)=>{let i=tA(o.Hash.sha256(tw(e,"utf8"))),r=`2-friend-${i}`;return t.deriveChild(t.toPublicKey(),r).toPublicKey().toString()};t.s(["createAuthToken",0,tO,"createType42",0,tE,"decrypt",0,tx,"deriveKeyForHost",0,tj,"deriveSharedKey",0,t_,"deriveType42",0,t$,"encrypt",0,tk,"getFriendPublicKey",0,tM,"parseToken",0,tB,"seed",0,tS,"seedToMasterKey",0,tK,"sign",0,tP,"verify",0,tI,"verifyToken",0,tD],7683),t.i(7683),t.s(["createAuthToken",0,tO,"createType42",0,tE,"decrypt",0,tx,"deriveKeyForHost",0,tj,"deriveSharedKey",0,t_,"deriveType42",0,t$,"encrypt",0,tk,"getAuthToken",()=>tf,"getFriendPublicKey",0,tM,"parseAuthToken",()=>tg,"parseToken",0,tB,"seed",0,tS,"seedToMasterKey",0,tK,"sign",0,tP,"verify",0,tI,"verifyAuthToken",()=>tm,"verifyToken",0,tD],20547);var tC=t.i(20547);let tN=e.default.homedir(),tT=i.default.join(tN,".tokenpass"),tF=globalThis,tW=(tF._tokenpassSeed||(tF._tokenpassSeed=new to({wallet:tC})),tF._tokenpassSeed),tz=(tF._tokenpassKey||(tF._tokenpassKey=new s({db:tT,wallet:tC,Datastore:r.default})),tF._tokenpassKey),tR=(tF._tokenpassState||(tF._tokenpassState=new td({db:tT,Datastore:r.default})),tF._tokenpassState);function tq(t){switch(t){case"forever":return 0;case"once":default:return 1e4;case"1h":return 36e5;case"1d":return 864e5;case"1w":return 6048e5;case"1m":return 2592e6}}t.s(["Key",0,tz,"Seed",0,tW,"State",0,tR,"Wallet",0,tC,"expireSelectionToTime",()=>tq],75792)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__a5a397b4._.js.map