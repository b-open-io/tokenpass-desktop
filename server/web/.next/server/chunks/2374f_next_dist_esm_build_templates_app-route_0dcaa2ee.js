module.exports=[79495,t=>{"use strict";var e=t.i(98490),i=t.i(18006),r=t.i(95912),s=t.i(72560),n=t.i(76852),a=t.i(38533),o=t.i(55822),h=t.i(54068),d=t.i(66843),l=t.i(99385),u=t.i(3050),y=t.i(75293),c=t.i(2144),p=t.i(33599),g=t.i(36497),f=t.i(93695);t.i(79178);var b=t.i(96717);t.i(79549);var v=t.i(34908),P=t.i(83745);t.i(48647);var A=t.i(41030);t.i(46182),t.i(52255),t.i(2769),t.i(40648),t.i(99847),t.i(73374);var A=A,K=async(t,e,i,r)=>{let s=`${i}${t}`;return(await fetch(s,{method:"post",headers:{"Content-type":"application/json; charset=utf-8",token:r,format:"json"},body:JSON.stringify(e)})).json()},m=(t,e)=>async(i,r)=>K(i,r,t,e),{toHex:E,toArray:S}=P.Utils,w="1BAPSuaPnfGnSBM3GLV9yhxUdYe4vGbdMT",I=E(S(w)),R="15PciHG22SNLQJXMoSUaWVi7WSqc7hCfva",N=(E(S(R)),"https://api.sigmaidentity.com/v1"),x="m/424150'/0'/0'",k="m/424150'/2147483647'/2147483647'",$="1-bap-identity",C={getRandomBytes(t=32){if("u">typeof globalThis&&globalThis.crypto&&globalThis.crypto.getRandomValues){let e=new Uint8Array(t);return globalThis.crypto.getRandomValues(e),e}throw Error("Secure random number generation not available. crypto.getRandomValues() is required for cryptographic operations. This environment may not be suitable for secure key generation.")},getRandomString(t=32){return Array.from(this.getRandomBytes(t),t=>t.toString(16).padStart(2,"0")).join("")},getSigningPathFromHex(t,e=!0){let i="m",r=t.match(/.{1,8}/g);if(!r)throw Error("Invalid hex string");for(let t of r){let r=Number(`0x${t}`);r>0x7fffffff&&(r-=0x7fffffff),i+=`/${r}${e?"'":""}`}return i},getNextIdentityPath(t){let e=t.split("/"),i=e[e.length-2],r=!1;i.match("'")&&(r=!0);let s=(Number(i.replace(/[^0-9]/g,""))+1).toString();return e[e.length-2]=s+(r?"'":""),e[e.length-1]=`0${r?"'":""}`,e.join("/")},getNextPath(t){let e=t.split("/"),i=e[e.length-1],r=!1;i.match("'")&&(r=!0);let s=(Number(i.replace(/[^0-9]/g,""))+1).toString();return e[e.length-1]=s+(r?"'":""),e.join("/")}},{toArray:D,toUTF8:T,toBase64:j}=P.Utils,{magicHash:O}=v.BSM,{electrumDecrypt:B,electrumEncrypt:H}=v.ECIES;class M{identityAttributes={};signWithBSM(t,e){let i=e.toPublicKey().toAddress(),r=v.BSM.sign(t,e,"raw"),s=new P.BigNumber(O(t)),n=r.CalculateRecoveryFactor(e.toPublicKey(),s);return{address:i,signature:v.BSM.sign(t,e,"raw").toCompact(n,!0,"base64")}}encrypt(t,e){let{privKey:i,pubKey:r}=this.getEncryptionKey(),s=e?P.PublicKey.fromString(e):r;return j(H(D(t),s,i))}decrypt(t,e){let{privKey:i}=this.getEncryptionKey(),r;return e&&(r=P.PublicKey.fromString(e)),T(B(D(t,"base64"),i,r))}signOpReturnWithAIP(t,e){let i=this.getAIPMessageBuffer(t),{address:r,signature:s}=this.signMessage(i.flat(),e);return this.formatAIPOutput(i,r,s)}getAttributes(){return this.identityAttributes}getAttribute(t){return this.identityAttributes[t]?this.identityAttributes[t]:null}setAttribute(t,e){e&&(this.identityAttributes[t]?this.updateExistingAttribute(t,e):this.createNewAttribute(t,e))}unsetAttribute(t){delete this.identityAttributes[t]}addAttribute(t,e,i=""){let r=i;i||(r=C.getRandomString()),this.identityAttributes[t]={value:e,nonce:r}}getAttributeUrns(){let t="";for(let e in this.identityAttributes){let i=this.getAttributeUrn(e);i&&(t+=`${i}
`)}return t}getAttributeUrn(t){let e=this.identityAttributes[t];return e?`urn:bap:id:${t}:${e.value}:${e.nonce}`:null}parseStringUrns(t){let e={};for(let i of t.replace(/^\s+/g,"").replace(/\r/gm,"").split(`
`)){let t=i.replace(/^\s+/g,"").replace(/\s+$/g,"").split(":");"urn"===t[0]&&"bap"===t[1]&&"id"===t[2]&&t[3]&&t[4]&&t[5]&&(e[t[3]]={value:t[4],nonce:t[5]})}return e}parseAttributes(t){if("string"==typeof t)return this.parseStringUrns(t);for(let e in t)if(!t[e].value||!t[e].nonce)throw Error("Invalid identity attribute");return t||{}}updateExistingAttribute(t,e){if("string"==typeof e){this.identityAttributes[t].value=e;return}this.identityAttributes[t].value=e.value||"",e.nonce&&(this.identityAttributes[t].nonce=e.nonce)}createNewAttribute(t,e){"string"==typeof e?this.addAttribute(t,e):this.addAttribute(t,e.value||"",e.nonce)}getAIPMessageBuffer(t,e){let i=t.findIndex(t=>t[0]===A.default.OP_RETURN),r=[];if(-1===i&&(r.push([A.default.OP_RETURN]),i=0),e)for(let s of e)r.push(t[i+s]);else for(let e of t)r.push(e);return r}formatAIPOutput(t,e,i){return[...t,D("|"),D(R),D("BITCOIN_ECDSA"),D(e),D(i,"base64")]}}var{toArray:z,toUTF8:W,toBase64:q,toHex:_}=P.Utils,{electrumDecrypt:U,electrumEncrypt:J}=v.ECIES;class F extends M{key;idName;description;address;identityKey;constructor(t,e={}){super(),this.key=t,this.address=this.getIdentitySigningKey().toPublicKey().toAddress(),this.idName="Member ID 1",this.description="",this.identityKey="",this.identityAttributes=this.parseAttributes(e)}getIdentitySigningKey(){return this.key.deriveChild(this.key.toPublicKey(),$)}getMemberKey(){return this.key.toPublicKey().toString()}getLegacyAddress(){return this.key.toPublicKey().toAddress()}signMessage(t,e){let i=this.getIdentitySigningKey();return this.signWithBSM(t,i)}signOpReturnWithAIP(t){let e=this.getAIPMessageBuffer(t),{address:i,signature:r}=this.signMessage(e.flat());return this.formatAIPOutput(e,i,r)}getPublicKey(){return this.getIdentitySigningKey().toPublicKey().toString()}import(t){this.idName=t.name,this.description=t.description,this.key=P.PrivateKey.fromWif(t.derivedPrivateKey),this.address=this.getIdentitySigningKey().toPublicKey().toAddress(),this.identityAttributes=t.identityAttributes||{},this.identityKey=t.identityKey}static fromMemberIdentity(t){let e=new F(P.PrivateKey.fromWif(t.derivedPrivateKey));return e.import(t),e}static fromBackup(t){let e=new F(P.PrivateKey.fromWif(t.wif)),i=JSON.parse(e.decrypt(t.id));return e.import(i),e}export(){return{name:this.idName,description:this.description,derivedPrivateKey:this.key.toWif(),address:this.address,identityAttributes:this.getAttributes(),identityKey:this.identityKey}}getEncryptionKey(){return{privKey:this.key.deriveChild(this.key.toPublicKey(),k),pubKey:this.key.deriveChild(this.key.toPublicKey(),k).toPublicKey()}}getEncryptionPublicKey(){let{pubKey:t}=this.getEncryptionKey();return t.toString()}getEncryptionPrivateKeyWithSeed(t){let e=_(P.Hash.sha256(t,"utf8"));return this.key.deriveChild(this.key.toPublicKey(),e)}getEncryptionKeyWithSeed(t){let e=this.getEncryptionPrivateKeyWithSeed(t);return{privKey:e,pubKey:e.toPublicKey()}}getEncryptionPublicKeyWithSeed(t){return this.getEncryptionPrivateKeyWithSeed(t).toPublicKey().toString()}encryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s=r.toPublicKey(),n=this.key.toPublicKey().constructor,a=i?n.fromString(i):s;return q(J(z(t),a,r))}decryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s;return i&&(s=P.PublicKey.fromString(i)),W(U(z(t,"base64"),r,s))}exportForBackup(t){let e=this.export(),i=this.encrypt(JSON.stringify(e));return{wif:this.key.toWif(),id:i,...t&&{label:t},createdAt:new Date().toISOString()}}}var{toArray:Q,toHex:L,toBase58:Z,toUTF8:V,toBase64:G}=P.Utils,{electrumDecrypt:X,electrumEncrypt:Y}=v.ECIES;class tt extends M{#t;#e;#i;#r=N;#s="";#n;#a;#o;#h;idName;description;rootAddress;identityKey;identityAttributes;getApiData;constructor(t,e={},i=""){if(super(),t instanceof v.HD)if(this.#i=!1,i){let e=L(P.Hash.sha256(i,"utf8")),r=C.getSigningPathFromHex(e);this.#t=t.derive(r)}else this.#t=t;else if(this.#i=!0,this.#e=t.rootPk,i){let t=L(P.Hash.sha256(i,"utf8"));this.#e=this.#e.deriveChild(this.#e.toPublicKey(),t)}if(this.#h=i,this.idName="ID 1",this.description="",this.#n=`${x}/0/0/0`,this.#a=`${x}/0/0/0`,this.#o=`${x}/0/0/1`,this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n);this.rootAddress=t.toPublicKey().toAddress()}else{if(!this.#t)throw Error("HD private key not initialized");let t=this.#t.derive(this.#n);this.rootAddress=t.privKey.toPublicKey().toAddress()}this.identityKey=this.deriveIdentityKey(this.rootAddress);let r={...e};this.identityAttributes=this.parseAttributes(r),this.getApiData=m(this.#r,this.#s)}set BAP_SERVER(t){this.#r=t}get BAP_SERVER(){return this.#r}set BAP_TOKEN(t){this.#s=t}get BAP_TOKEN(){return this.#s}deriveIdentityKey(t){let e=L(P.Hash.sha256(t,"utf8"));return Z(P.Hash.ripemd160(e,"hex"))}parseAttributes(t){if("string"==typeof t)return this.parseStringUrns(t);for(let e in t)if(!t[e].value||!t[e].nonce)throw Error("Invalid identity attribute");return t||{}}parseStringUrns(t){let e={};for(let i of t.replace(/^\s+/g,"").replace(/\r/gm,"").split(`
`)){let t=i.replace(/^\s+/g,"").replace(/\s+$/g,"").split(":");"urn"===t[0]&&"bap"===t[1]&&"id"===t[2]&&t[3]&&t[4]&&t[5]&&(e[t[3]]={value:t[4],nonce:t[5]})}return e}getIdentityKey(){return this.identityKey}set rootPath(t){if(this.#i){if(this.#n=t,!this.#e)throw Error("Master private key not initialized");let e=this.#e.deriveChild(this.#e.toPublicKey(),t);this.rootAddress=e.toPublicKey().toAddress(),this.#a=t,this.#o=t}else{let e=t;if(t.split("/").length<5&&(e=`${x}${t}`),!this.validatePath(e))throw Error(`invalid signing path given ${e}`);if(this.#n=e,!this.#t)throw Error("HD private key not initialized");let i=this.#t.derive(e);this.rootAddress=i.pubKey.toAddress(),this.#a=e,this.#o=e}this.identityKey=this.deriveIdentityKey(this.rootAddress)}get rootPath(){return this.#n}getRootPath(){return this.#n}set currentPath(t){if(this.#i)this.#a=this.#o,this.#o=t;else{let e=t;if(t.split("/").length<5&&(e=`${x}${t}`),!this.validatePath(e))throw Error("invalid signing path given");this.#a=this.#o,this.#o=e}}get currentPath(){return this.#o}get previousPath(){return this.#a}get idSeed(){return this.#h}incrementPath(){this.currentPath=C.getNextPath(this.currentPath)}validatePath(t){if(t.match(/\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?\/[0-9]{1,10}'?/)){let e=t.split("/");if(7===e.length&&0x7fffffff>=Number(e[1].replace("'",""))&&0x7fffffff>=Number(e[2].replace("'",""))&&0x7fffffff>=Number(e[3].replace("'",""))&&0x7fffffff>=Number(e[4].replace("'",""))&&0x7fffffff>=Number(e[5].replace("'",""))&&0x7fffffff>=Number(e[6].replace("'","")))return!0}return!1}getInitialIdTransaction(){return this.getIdTransaction(this.#n)}getIdTransaction(t=""){if(this.#o===this.#n)throw Error("Current path equals rootPath. ID was probably not initialized properly");let e=[Q(w),Q("ID"),Q(this.identityKey),Q(this.getCurrentAddress())];return this.signOpReturnWithAIP(e,t||this.#a)}getPathDerivedKey(t){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");return this.#e.deriveChild(this.#e.toPublicKey(),t)}if(!this.#t)throw Error("HD private key not initialized");return this.#t.derive(t).privKey}getIdentitySigningKeyForPath(t){let e=this.getPathDerivedKey(t);return e.deriveChild(e.toPublicKey(),$)}getMemberKey(t){let e=t||this.#o;return this.getPathDerivedKey(e).toPublicKey().toString()}getLegacyAddress(t){let e=t||this.#o;return this.getPathDerivedKey(e).toPublicKey().toAddress()}needsRotation(t){return(t||this.rootAddress)===this.getLegacyAddress(this.#n)}getLegacyRotationTransaction(){let t=this.getAddress(this.#n),e=[Q(w),Q("ID"),Q(this.identityKey),Q(t)],i=this.getAIPMessageBuffer(e),r=this.getPathDerivedKey(this.#n),{address:s,signature:n}=this.signWithBSM(i.flat(),r);return this.formatAIPOutput(e,s,n)}getAddress(t){return this.getIdentitySigningKeyForPath(t).toPublicKey().toAddress()}getCurrentAddress(){return this.getAddress(this.#o)}getEncryptionKey(){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n),e=t.deriveChild(t.toPublicKey(),k);return{privKey:e,pubKey:e.toPublicKey()}}if(!this.#t)throw Error("HD private key not initialized");let t=this.#t.derive(this.#n).derive(k).privKey;return{privKey:t,pubKey:t.toPublicKey()}}getEncryptionKeyType42(){if(this.#i)return this.getEncryptionKey();if(!this.#t)throw Error("HD private key not initialized");let t=this.#t.derive(this.#n),e=t.privKey.deriveChild(t.toPublic().pubKey,k);return{privKey:e,pubKey:e.toPublicKey()}}getEncryptionPublicKey(){let{pubKey:t}=this.getEncryptionKey();return t.toString()}getEncryptionPublicKeyWithSeed(t){return this.getEncryptionPrivateKeyWithSeed(t).toPublicKey().toString()}encrypt(t,e){let{privKey:i,pubKey:r}=this.getEncryptionKey(),s=e?P.PublicKey.fromString(e):r;return G(Y(Q(t),s,i))}decrypt(t,e){let{privKey:i}=this.getEncryptionKey(),r;return e&&(r=P.PublicKey.fromString(e)),V(X(Q(t,"base64"),i,r))}encryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s=r.toPublicKey(),n=i?P.PublicKey.fromString(i):s;return G(Y(Q(t),n,r))}decryptWithSeed(t,e,i){let r=this.getEncryptionPrivateKeyWithSeed(e),s;return i&&(s=P.PublicKey.fromString(i)),V(X(Q(t,"base64"),r,s))}getEncryptionPrivateKeyWithSeed(t){let e=L(P.Hash.sha256(t,"utf8"));if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n);return t.deriveChild(t.toPublicKey(),e)}if(!this.#t)throw Error("HD private key not initialized");let i=C.getSigningPathFromHex(e);return this.#t.derive(this.#n).derive(i).privKey}getAttestation(t){let e=P.Hash.sha256(t,"utf8");return`bap:attest:${L(e)}:${this.getIdentityKey()}`}getAttestationHash(t){let e=this.getAttributeUrn(t);if(!e)return null;let i=this.getAttestation(e);return L(P.Hash.sha256(i,"utf8"))}signMessage(t,e){let i=e||this.#o,r=this.getIdentitySigningKeyForPath(i);return this.signWithBSM(t,r)}signMessageWithSeed(t,e){let i=L(P.Hash.sha256(e,"utf8")),r;if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let t=this.#e.deriveChild(this.#e.toPublicKey(),this.#n);r=t.deriveChild(t.toPublicKey(),i)}else{if(!this.#t)throw Error("HD private key not initialized");let t=C.getSigningPathFromHex(i);r=this.#t.derive(this.#n).derive(t).privKey}let s=r.deriveChild(r.toPublicKey(),$);return this.signWithBSM(Q(t,"utf8"),s)}signOpReturnWithAIP(t,e=""){let i=this.getAIPMessageBuffer(t),{address:r,signature:s}=this.signMessage(i.flat(),e);return this.formatAIPOutput(t,r,s)}async getIdSigningKeys(){let t=await this.getApiData("/signing-keys",{idKey:this.identityKey});return console.log("getIdSigningKeys",t),t}async getAttributeAttestations(t){let e=this.getAttestationHash(t),i=await this.getApiData("/attestation/get",{hash:e});return console.log("getAttestations",t,e,i),i}import(t){this.idName=t.name,this.description=t.description||"",this.identityKey=t.identityKey,this.#n=t.rootPath,this.rootAddress=t.rootAddress,this.#a=t.previousPath,this.#o=t.currentPath,this.#h=("idSeed"in t?t.idSeed:"")||"",this.identityAttributes=this.parseAttributes(t.identityAttributes)}export(){return{name:this.idName,description:this.description,identityKey:this.identityKey,rootPath:this.#n,rootAddress:this.rootAddress,previousPath:this.#a,currentPath:this.#o,idSeed:this.#h,identityAttributes:this.getAttributes(),lastIdPath:""}}exportMemberBackup(){let t=this.getPathDerivedKey(this.#o),e=this.getIdentitySigningKeyForPath(this.#o);return{name:this.idName,description:this.description,derivedPrivateKey:t.toWif(),address:e.toPublicKey().toAddress(),identityAttributes:this.getAttributes(),identityKey:this.identityKey}}newId(){return this.incrementPath(),new F(this.getPathDerivedKey(this.#o))}exportMember(){let t=this.exportMemberBackup(),e=this.getPathDerivedKey(this.#o),i=G(Y(Q(JSON.stringify(t)),e.toPublicKey()));return{wif:t.derivedPrivateKey,encryptedData:i}}}var{toArray:te,toUTF8:ti,toBase64:tr,toHex:ts}=P.Utils,{electrumEncrypt:tn,electrumDecrypt:ta}=v.ECIES;class to{#t;#e;#i;#r={};#s=N;#n="";#a="";#o=0;getApiData;constructor(t,e="",i=""){if(!t)throw Error("No key source given");"string"==typeof t?(this.#t=v.HD.fromString(t),this.#i=!1):(this.#e=P.PrivateKey.fromWif(t.rootPk),this.#i=!0),e&&(this.#n=e),i&&(this.#s=i),this.getApiData=m(this.#s,this.#n)}get lastIdPath(){return this.#a}getPublicKey(t=""){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");return t?this.#e.deriveChild(this.#e.toPublicKey(),t).toPublicKey().toString():this.#e.toPublicKey().toString()}if(!this.#t)throw Error("HD private key not initialized");return t?this.#t.derive(t).pubKey.toString():this.#t.pubKey.toString()}getHdPublicKey(t=""){if(this.#i)throw Error("HD public keys are not available in Type 42 mode");if(!this.#t)throw Error("HD private key not initialized");return t?this.#t.derive(t).toPublic().toString():this.#t.toPublic().toString()}set BAP_SERVER(t){for(let e in this.#s=t,this.#r)this.#r[e].BAP_SERVER=t}get BAP_SERVER(){return this.#s}set BAP_TOKEN(t){for(let e in this.#n=t,this.#r)this.#r[e].BAP_TOKEN=t}get BAP_TOKEN(){return this.#n}checkIdBelongs(t){let e;if(this.#i){if(!this.#e)throw Error("Master private key not initialized");e=this.#e.deriveChild(this.#e.toPublicKey(),t.rootPath).toPublicKey().toAddress()}else{if(!this.#t)throw Error("HD private key not initialized");e=this.#t.derive(t.rootPath).pubKey.toAddress()}if(e!==t.rootAddress)throw Error("ID does not belong to this private key");return!0}listIds(){return Object.keys(this.#r)}newId(t,e,i={},r=""){let s,n,a,o,h;if("object"==typeof t||void 0===t||"string"==typeof t&&t.startsWith("/")?(n="string"==typeof t?t:void 0,a="object"==typeof t?t:"object"==typeof e?e:{},s="Default Identity"):(s=t,n="string"==typeof e?e:void 0,a="object"==typeof e?e:i),n?o=n:this.#i?(o=`bap:${this.#o}`,this.#o++):o=this.getNextValidPath(),this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");h=new tt({rootPk:this.#e},a,r)}else{if(!this.#t)throw Error("HD private key not initialized");h=new tt(this.#t,a,r)}(h.BAP_SERVER=this.#s,h.BAP_TOKEN=this.#n,h.idName=s,h.rootPath=o,this.#i)?h.currentPath=o:h.currentPath=C.getNextPath(o);let d=h.getIdentityKey();return this.#r[d]=h,this.#a=o,this.#r[d]}removeId(t){delete this.#r[t]}getNextValidPath(){return this.#a?C.getNextIdentityPath(this.#a):`/0'/${Object.keys(this.#r).length}'/0'`}newIdWithCounter(t,e=`Identity ${t}`){if(!this.#i)throw Error("newIdWithCounter only works in Type 42 mode");let i=`bap:${t}`;return this.newId(e,i)}getId(t){return this.#r[t]||null}setId(t){this.checkIdBelongs(t),this.#r[t.getIdentityKey()]=t}importIds(t,e=!0){if(e&&"string"==typeof t)return void this.importEncryptedIds(t);if(!t.lastIdPath)throw Error("ID cannot be imported as it is not complete");if(!t.ids)throw Error(`ID data is not in the correct format: ${t}`);let i=t.lastIdPath;for(let e of t.ids){let t;if(!e.identityKey||!e.identityAttributes||!e.rootAddress)throw Error("ID cannot be imported as it is not complete");if(this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");t=new tt({rootPk:this.#e},{},e.idSeed)}else{if(!this.#t)throw Error("HD private key not initialized");t=new tt(this.#t,{},e.idSeed)}if(t.BAP_SERVER=this.#s,t.BAP_TOKEN=this.#n,t.import(e),""===i&&(i=t.currentPath),this.checkIdBelongs(t),this.#r[t.getIdentityKey()]=t,this.#i&&t.rootPath.startsWith("bap:")){let e=t.rootPath.split(":");if(e.length>=2){let t=Number.parseInt(e[1],10);Number.isNaN(t)||(this.#o=Math.max(this.#o,t+1))}}}this.#a=i}importEncryptedIds(t){let e=JSON.parse(this.decrypt(t));if(Array.isArray(e)){console.log(`Importing old format:
`,e),this.importOldIds(e);return}if("object"!=typeof e)throw Error("decrypted, but found unrecognized identities format");this.importIds(e,!1)}importOldIds(t){for(let e of t){let t;if(this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");t=new tt({rootPk:this.#e},{},e.idSeed??"")}else{if(!this.#t)throw Error("HD private key not initialized");t=new tt(this.#t,{},e.idSeed??"")}t.BAP_SERVER=this.#s,t.BAP_TOKEN=this.#n,t.import(e),this.checkIdBelongs(t),this.#r[t.getIdentityKey()]=t,this.#a=t.currentPath}}exportIds(t,e=!0){let i={lastIdPath:this.#a,ids:[]};for(let e of t||Object.keys(this.#r)){if(!this.#r[e])throw Error(`Identity ${e} not found`);i.ids.push(this.#r[e].export())}return e?this.encrypt(JSON.stringify(i)):i}exportId(t,e=!0){let i={lastIdPath:this.#a,ids:[]};return(i.ids.push(this.#r[t].export()),e)?this.encrypt(JSON.stringify(i)):i}encrypt(t){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let e=this.#e.deriveChild(this.#e.toPublicKey(),k);return tr(tn(te(t),e.toPublicKey(),null))}if(!this.#t)throw Error("HD private key not initialized");let e=this.#t.derive(k);return tr(tn(te(t),e.pubKey,null))}decrypt(t){if(this.#i){if(!this.#e)throw Error("Master private key not initialized");let e=this.#e.deriveChild(this.#e.toPublicKey(),k);return ti(ta(te(t,"base64"),e))}if(!this.#t)throw Error("HD private key not initialized");let e=this.#t.derive(k);return ti(ta(te(t,"base64"),e.privKey))}signAttestationWithAIP(t,e,i=0,r=""){let s=this.getId(e);if(!s)throw Error("Could not find identity to attest with");let n=this.getAttestationBuffer(t,i,r),{address:a,signature:o}=s.signMessage(n);return this.createAttestationTransaction(t,i,a,o,r)}verifyAttestationWithAIP(t){if(!t.every(t=>Array.isArray(t))||t[0][0]!==A.default.OP_RETURN||ts(t[1])!==I)throw Error("Not a valid BAP transaction");let e=5*("44415441"===ts(t[7])),i={type:ti(t[2]),hash:ts(t[3]),sequence:ti(t[4]),signingProtocol:ti(t[7+e]),signingAddress:ti(t[8+e]),signature:tr(t[9+e])};e&&t[3]===t[8]&&(i.data=ts(t[9])),console.log({attestation:i});try{let r=[];for(let i=0;i<6+e;i++)r.push(t[i]);i.verified=this.verifySignature(r.flat(),i.signingAddress,i.signature)}catch{i.verified=!1}return i}createAttestationTransaction(t,e,i,r,s=""){let n=[[A.default.OP_RETURN],te(w),te("ATTEST"),te(t),te(`${e}`),te("|")];return s&&n.push(te(w),te("DATA"),te(t),te(s),te("|")),n.push(te(R),te("BITCOIN_ECDSA"),te(i),te(r,"base64")),console.log({elements:n}),n}getAttestationBuffer(t,e=0,i=""){let r=[[A.default.OP_RETURN],te(w),te("ATTEST"),te(t),te(`${e}`),te("|")];return i&&r.push(te(w),te("DATA"),te(t),te(i),te("|")),r.flat()}verifySignature(t,e,i){let r;r=Array.isArray(t)?t:Buffer.isBuffer(t)?[...t]:te(t,"utf8");let s=P.Signature.fromCompact(i,"base64"),n;for(let t=0;t<4;t++)try{if(n=s.RecoverPublicKey(t,new P.BigNumber(v.BSM.magicHash(r))),v.BSM.verify(r,s,n)&&n.toAddress()===e)return!0}catch{}return!1}async verifyChallengeSignature(t,e,i,r){if(!this.verifySignature(i,e,r))return!1;try{let s=await this.getApiData("/attestation/valid",{idKey:t,address:e,challenge:i,signature:r});if(s?.status==="success"&&s?.result?.valid===!0)return!0;return!1}catch(t){return console.error("API call failed:",t),!1}}async isValidAttestationTransaction(t){return!!this.verifyAttestationWithAIP(t)&&this.getApiData("/attestation/valid",{tx:t})}async getIdentityFromAddress(t){return this.getApiData("/identity/from-address",{address:t})}async getIdentity(t){return this.getApiData("/identity/get",{idKey:t})}async getAttestationsForHash(t){return this.getApiData("/attestations",{hash:t})}exportForBackup(t,e,i){let r={ids:this.exportIds(),...t&&{label:t},createdAt:new Date().toISOString()};if(this.#i){if(!this.#e)throw Error("Type 42 parameters not initialized");return{...r,rootPk:this.#e.toWif()}}if(!this.#t)throw Error("HD private key not initialized");return{...r,xprv:e||this.#t.toString(),mnemonic:i||""}}exportMemberForBackup(t,e){let i=this.#r[t];if(!i)throw Error(`Identity ${t} not found`);let r=i.exportMember();return{wif:r.wif,id:r.encryptedData,...e&&{label:e},createdAt:new Date().toISOString()}}}var th=t.i(23480),td=t.i(48797),tl=t.i(54015),tu=t.i(94488);let{toArray:ty}=P.Utils;async function tc(t){let e=(0,td.getClientIdentifier)(t.headers),i=await (0,td.rateLimit)(`register:${e}`);if(!i.success)return th.NextResponse.json({error:"Too many registration attempts. Please try again later.",retryAfter:Math.ceil((i.reset-Date.now())/1e3)},{status:429,headers:{"Retry-After":String(Math.ceil((i.reset-Date.now())/1e3)),"X-RateLimit-Limit":String(i.limit),"X-RateLimit-Remaining":String(i.remaining)}});let r=await t.json(),s=(0,tl.validateBody)(tl.registerSchema,r);if(!s.success)return th.NextResponse.json({error:s.error},{status:400});let{password:n,displayName:a,paymail:o,logo:h}=s.data,d=await tu.Seed.create(n),l=new to(v.HD.fromSeed(ty(d.hex,"hex")).toString()).newId();tu.Key.setSeed(d);let u=await tu.State.findOrCreate({host:process.env.TOKENPASS_HOST||"localhost"});u.icon||(u.icon="/api/auth/icon"),await tu.State.update(u);let y=await tu.State.findOrCreate({host:"global"});return a&&l.setAttribute("displayName",a),o&&l.setAttribute("paymail",o),h&&l.setAttribute("logo",h),y={...y,...Object.keys(l.identityAttributes).reduce((t,e)=>(t[e]=l.identityAttributes[e].value,t),{}),bapID:l.identityKey},await tu.State.update(y),th.NextResponse.json({success:!0})}t.s(["POST",()=>tc],83130);var tp=t.i(83130);let tg=new e.AppRouteRouteModule({definition:{kind:i.RouteKind.APP_ROUTE,page:"/api/register/route",pathname:"/api/register",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/web/src/app/api/register/route.ts",nextConfigOutput:"standalone",userland:tp}),{workAsyncStorage:tf,workUnitAsyncStorage:tb,serverHooks:tv}=tg;function tP(){return(0,r.patchFetch)({workAsyncStorage:tf,workUnitAsyncStorage:tb})}async function tA(t,e,r){tg.isDev&&(0,s.addRequestMeta)(t,"devRequestTimingInternalsEnd",process.hrtime.bigint());let v="/api/register/route";v=v.replace(/\/index$/,"")||"/";let P=await tg.prepare(t,e,{srcPage:v,multiZoneDraftMode:!1});if(!P)return e.statusCode=400,e.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:A,params:K,nextConfig:m,parsedUrl:E,isDraftMode:S,prerenderManifest:w,routerServerContext:I,isOnDemandRevalidate:R,revalidateOnlyGenerated:N,resolvedPathname:x,clientReferenceManifest:k,serverActionsManifest:$}=P,C=(0,o.normalizeAppPath)(v),D=!!(w.dynamicRoutes[C]||w.routes[x]),T=async()=>((null==I?void 0:I.render404)?await I.render404(t,e,E,!1):e.end("This page could not be found"),null);if(D&&!S){let t=!!w.routes[x],e=w.dynamicRoutes[C];if(e&&!1===e.fallback&&!t){if(m.experimental.adapterPath)return await T();throw new f.NoFallbackError}}let j=null;!D||tg.isDev||S||(j="/index"===(j=x)?"/":j);let O=!0===tg.isDev||!D,B=D&&!O;$&&k&&(0,a.setManifestsSingleton)({page:v,clientReferenceManifest:k,serverActionsManifest:$});let H=t.method||"GET",M=(0,n.getTracer)(),z=M.getActiveScopeSpan(),W={params:K,prerenderManifest:w,renderOpts:{experimental:{authInterrupts:!!m.experimental.authInterrupts},cacheComponents:!!m.cacheComponents,supportsDynamicResponse:O,incrementalCache:(0,s.getRequestMeta)(t,"incrementalCache"),cacheLifeProfiles:m.cacheLife,waitUntil:r.waitUntil,onClose:t=>{e.on("close",t)},onAfterTaskError:void 0,onInstrumentationRequestError:(e,i,r,s)=>tg.onRequestError(t,e,r,s,I)},sharedContext:{buildId:A}},q=new h.NodeNextRequest(t),_=new h.NodeNextResponse(e),U=d.NextRequestAdapter.fromNodeNextRequest(q,(0,d.signalFromNodeResponse)(e));try{let a=async t=>tg.handle(U,W).finally(()=>{if(!t)return;t.setAttributes({"http.status_code":e.statusCode,"next.rsc":!1});let i=M.getRootSpanAttributes();if(!i)return;if(i.get("next.span_type")!==l.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${i.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let r=i.get("next.route");if(r){let e=`${H} ${r}`;t.setAttributes({"next.route":r,"http.route":r,"next.span_name":e}),t.updateName(e)}else t.updateName(`${H} ${v}`)}),o=!!(0,s.getRequestMeta)(t,"minimalMode"),h=async s=>{var n,h;let d=async({previousCacheEntry:i})=>{try{if(!o&&R&&N&&!i)return e.statusCode=404,e.setHeader("x-nextjs-cache","REVALIDATED"),e.end("This page could not be found"),null;let n=await a(s);t.fetchMetrics=W.renderOpts.fetchMetrics;let h=W.renderOpts.pendingWaitUntil;h&&r.waitUntil&&(r.waitUntil(h),h=void 0);let d=W.renderOpts.collectedTags;if(!D)return await (0,y.sendResponse)(q,_,n,W.renderOpts.pendingWaitUntil),null;{let t=await n.blob(),e=(0,c.toNodeOutgoingHttpHeaders)(n.headers);d&&(e[g.NEXT_CACHE_TAGS_HEADER]=d),!e["content-type"]&&t.type&&(e["content-type"]=t.type);let i=void 0!==W.renderOpts.collectedRevalidate&&!(W.renderOpts.collectedRevalidate>=g.INFINITE_CACHE)&&W.renderOpts.collectedRevalidate,r=void 0===W.renderOpts.collectedExpire||W.renderOpts.collectedExpire>=g.INFINITE_CACHE?void 0:W.renderOpts.collectedExpire;return{value:{kind:b.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await t.arrayBuffer()),headers:e},cacheControl:{revalidate:i,expire:r}}}}catch(e){throw(null==i?void 0:i.isStale)&&await tg.onRequestError(t,e,{routerKind:"App Router",routePath:v,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:B,isOnDemandRevalidate:R})},!1,I),e}},l=await tg.handleResponse({req:t,nextConfig:m,cacheKey:j,routeKind:i.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:w,isRoutePPREnabled:!1,isOnDemandRevalidate:R,revalidateOnlyGenerated:N,responseGenerator:d,waitUntil:r.waitUntil,isMinimalMode:o});if(!D)return null;if((null==l||null==(n=l.value)?void 0:n.kind)!==b.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(h=l.value)?void 0:h.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});o||e.setHeader("x-nextjs-cache",R?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),S&&e.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let f=(0,c.fromNodeOutgoingHttpHeaders)(l.value.headers);return o&&D||f.delete(g.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||e.getHeader("Cache-Control")||f.get("Cache-Control")||f.set("Cache-Control",(0,p.getCacheControlHeader)(l.cacheControl)),await (0,y.sendResponse)(q,_,new Response(l.value.body,{headers:f,status:l.value.status||200})),null};z?await h(z):await M.withPropagatedContext(t.headers,()=>M.trace(l.BaseServerSpan.handleRequest,{spanName:`${H} ${v}`,kind:n.SpanKind.SERVER,attributes:{"http.method":H,"http.target":t.url}},h))}catch(e){if(e instanceof f.NoFallbackError||await tg.onRequestError(t,e,{routerKind:"App Router",routePath:C,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:B,isOnDemandRevalidate:R})},!1,I),D)throw e;return await (0,y.sendResponse)(q,_,new Response(null,{status:500})),null}}t.s(["handler",()=>tA,"patchFetch",()=>tP,"routeModule",()=>tg,"serverHooks",()=>tv,"workAsyncStorage",()=>tf,"workUnitAsyncStorage",()=>tb],79495)}];

//# sourceMappingURL=2374f_next_dist_esm_build_templates_app-route_0dcaa2ee.js.map